using Win32.Foundation;
using Win32.System.Com;
using System;

namespace Win32.System.Antimalware;

#region TypeDefs
typealias HAMSICONTEXT = int;

typealias HAMSISESSION = int;

#endregion


#region Enums

[AllowDuplicates]
public enum AMSI_RESULT : int32
{
	AMSI_RESULT_CLEAN = 0,
	AMSI_RESULT_NOT_DETECTED = 1,
	AMSI_RESULT_BLOCKED_BY_ADMIN_START = 16384,
	AMSI_RESULT_BLOCKED_BY_ADMIN_END = 20479,
	AMSI_RESULT_DETECTED = 32768,
}


[AllowDuplicates]
public enum AMSI_ATTRIBUTE : int32
{
	AMSI_ATTRIBUTE_APP_NAME = 0,
	AMSI_ATTRIBUTE_CONTENT_NAME = 1,
	AMSI_ATTRIBUTE_CONTENT_SIZE = 2,
	AMSI_ATTRIBUTE_CONTENT_ADDRESS = 3,
	AMSI_ATTRIBUTE_SESSION = 4,
	AMSI_ATTRIBUTE_REDIRECT_CHAIN_SIZE = 5,
	AMSI_ATTRIBUTE_REDIRECT_CHAIN_ADDRESS = 6,
	AMSI_ATTRIBUTE_ALL_SIZE = 7,
	AMSI_ATTRIBUTE_ALL_ADDRESS = 8,
	AMSI_ATTRIBUTE_QUIET = 9,
}


[AllowDuplicates]
public enum AMSI_UAC_REQUEST_TYPE : int32
{
	AMSI_UAC_REQUEST_TYPE_EXE = 0,
	AMSI_UAC_REQUEST_TYPE_COM = 1,
	AMSI_UAC_REQUEST_TYPE_MSI = 2,
	AMSI_UAC_REQUEST_TYPE_AX = 3,
	AMSI_UAC_REQUEST_TYPE_PACKAGED_APP = 4,
	AMSI_UAC_REQUEST_TYPE_MAX = 5,
}


[AllowDuplicates]
public enum AMSI_UAC_TRUST_STATE : int32
{
	AMSI_UAC_TRUST_STATE_TRUSTED = 0,
	AMSI_UAC_TRUST_STATE_UNTRUSTED = 1,
	AMSI_UAC_TRUST_STATE_BLOCKED = 2,
	AMSI_UAC_TRUST_STATE_MAX = 3,
}


[AllowDuplicates]
public enum AMSI_UAC_MSI_ACTION : int32
{
	AMSI_UAC_MSI_ACTION_INSTALL = 0,
	AMSI_UAC_MSI_ACTION_UNINSTALL = 1,
	AMSI_UAC_MSI_ACTION_UPDATE = 2,
	AMSI_UAC_MSI_ACTION_MAINTENANCE = 3,
	AMSI_UAC_MSI_ACTION_MAX = 4,
}

#endregion


#region Structs
[CRepr]
public struct AMSI_UAC_REQUEST_EXE_INFO
{
	public uint32 ulLength;
	public PWSTR lpwszApplicationName;
	public PWSTR lpwszCommandLine;
	public PWSTR lpwszDLLParameter;
}

[CRepr]
public struct AMSI_UAC_REQUEST_COM_INFO
{
	public uint32 ulLength;
	public PWSTR lpwszServerBinary;
	public PWSTR lpwszRequestor;
	public Guid Clsid;
}

[CRepr]
public struct AMSI_UAC_REQUEST_MSI_INFO
{
	public uint32 ulLength;
	public AMSI_UAC_MSI_ACTION MsiAction;
	public PWSTR lpwszProductName;
	public PWSTR lpwszVersion;
	public PWSTR lpwszLanguage;
	public PWSTR lpwszManufacturer;
	public PWSTR lpwszPackagePath;
	public PWSTR lpwszPackageSource;
	public uint32 ulUpdates;
	public PWSTR* ppwszUpdates;
	public PWSTR* ppwszUpdateSources;
}

[CRepr]
public struct AMSI_UAC_REQUEST_AX_INFO
{
	public uint32 ulLength;
	public PWSTR lpwszLocalInstallPath;
	public PWSTR lpwszSourceURL;
}

[CRepr]
public struct AMSI_UAC_REQUEST_PACKAGED_APP_INFO
{
	public uint32 ulLength;
	public PWSTR lpwszApplicationName;
	public PWSTR lpwszCommandLine;
	public PWSTR lpPackageFamilyName;
	public PWSTR lpApplicationId;
}

[CRepr]
public struct AMSI_UAC_REQUEST_CONTEXT
{
	[CRepr, Union]
	public struct _RequestType_e__Union
	{
		public AMSI_UAC_REQUEST_EXE_INFO ExeInfo;
		public AMSI_UAC_REQUEST_COM_INFO ComInfo;
		public AMSI_UAC_REQUEST_MSI_INFO MsiInfo;
		public AMSI_UAC_REQUEST_AX_INFO ActiveXInfo;
		public AMSI_UAC_REQUEST_PACKAGED_APP_INFO PackagedAppInfo;
	}
	public uint32 ulLength;
	public uint32 ulRequestorProcessId;
	public AMSI_UAC_TRUST_STATE UACTrustState;
	public AMSI_UAC_REQUEST_TYPE Type;
	public _RequestType_e__Union RequestType;
	public BOOL bAutoElevateRequest;
}

#endregion

#region COM Class IDs
public static
{
	public const Guid CLSID_CAntimalware = .(0xfdb00e52, 0xa214, 0x4aa1, 0x8f, 0xba, 0x43, 0x57, 0xbb, 0x00, 0x72, 0xec);


}
#endregion

#region COM Types
[CRepr]struct IAmsiStream : IUnknown
{
	public new const Guid IID = .(0x3e47f2e5, 0x81d4, 0x4d3b, 0x89, 0x7f, 0x54, 0x50, 0x96, 0x77, 0x03, 0x73);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, AMSI_ATTRIBUTE attribute, uint32 dataSize, uint8* data, uint32* retData) GetAttribute;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint64 position, uint32 size, uint8* buffer, uint32* readSize) Read;
	}


	public HRESULT GetAttribute(AMSI_ATTRIBUTE attribute, uint32 dataSize, uint8* data, uint32* retData) mut => VT.[Friend]GetAttribute(&this, attribute, dataSize, data, retData);

	public HRESULT Read(uint64 position, uint32 size, uint8* buffer, uint32* readSize) mut => VT.[Friend]Read(&this, position, size, buffer, readSize);
}

[CRepr]struct IAntimalwareProvider : IUnknown
{
	public new const Guid IID = .(0xb2cabfe3, 0xfe04, 0x42b1, 0xa5, 0xdf, 0x08, 0xd4, 0x83, 0xd4, 0xd1, 0x25);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IAmsiStream* stream, AMSI_RESULT* result) Scan;
		protected new function [CallingConvention(.Stdcall)] void(SelfOuter* self, uint64 session) CloseSession;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, PWSTR* displayName) DisplayName;
	}


	public HRESULT Scan(IAmsiStream* stream, AMSI_RESULT* result) mut => VT.[Friend]Scan(&this, stream, result);

	public void CloseSession(uint64 session) mut => VT.[Friend]CloseSession(&this, session);

	public HRESULT DisplayName(PWSTR* displayName) mut => VT.[Friend]DisplayName(&this, displayName);
}

[CRepr]struct IAntimalwareUacProvider : IUnknown
{
	public new const Guid IID = .(0xb2cabfe4, 0xfe04, 0x42b1, 0xa5, 0xdf, 0x08, 0xd4, 0x83, 0xd4, 0xd1, 0x25);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, AMSI_UAC_REQUEST_CONTEXT* context, AMSI_RESULT* result) UacScan;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, PWSTR* displayName) DisplayName;
	}


	public HRESULT UacScan(AMSI_UAC_REQUEST_CONTEXT* context, AMSI_RESULT* result) mut => VT.[Friend]UacScan(&this, context, result);

	public HRESULT DisplayName(PWSTR* displayName) mut => VT.[Friend]DisplayName(&this, displayName);
}

[CRepr]struct IAntimalwareProvider2 : IAntimalwareProvider
{
	public new const Guid IID = .(0x7c1e6570, 0x3f73, 0x4e0f, 0x8a, 0xd4, 0x98, 0xb9, 0x4c, 0xd3, 0x29, 0x0f);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IAntimalwareProvider.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, void* buffer, uint32 length, PWSTR contentName, PWSTR appName, AMSI_RESULT* pResult) Notify;
	}


	public HRESULT Notify(void* buffer, uint32 length, PWSTR contentName, PWSTR appName, AMSI_RESULT* pResult) mut => VT.[Friend]Notify(&this, buffer, length, contentName, appName, pResult);
}

[CRepr]struct IAntimalware : IUnknown
{
	public new const Guid IID = .(0x82d29c2e, 0xf062, 0x44e6, 0xb5, 0xc9, 0x3d, 0x9a, 0x2f, 0x24, 0xa2, 0xdf);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IAmsiStream* stream, AMSI_RESULT* result, IAntimalwareProvider** provider) Scan;
		protected new function [CallingConvention(.Stdcall)] void(SelfOuter* self, uint64 session) CloseSession;
	}


	public HRESULT Scan(IAmsiStream* stream, AMSI_RESULT* result, IAntimalwareProvider** provider) mut => VT.[Friend]Scan(&this, stream, result, provider);

	public void CloseSession(uint64 session) mut => VT.[Friend]CloseSession(&this, session);
}

[CRepr]struct IAntimalware2 : IAntimalware
{
	public new const Guid IID = .(0x301035b5, 0x2d42, 0x4f56, 0x8c, 0x65, 0x2d, 0xca, 0xa7, 0xfb, 0x3c, 0xdc);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IAntimalware.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, void* buffer, uint32 length, PWSTR contentName, PWSTR appName, AMSI_RESULT* pResult) Notify;
	}


	public HRESULT Notify(void* buffer, uint32 length, PWSTR contentName, PWSTR appName, AMSI_RESULT* pResult) mut => VT.[Friend]Notify(&this, buffer, length, contentName, appName, pResult);
}

#endregion

#region Functions
public static
{
	[Import("Amsi.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern HRESULT AmsiInitialize(PWSTR appName, HAMSICONTEXT* amsiContext);

	[Import("Amsi.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern void AmsiUninitialize(HAMSICONTEXT amsiContext);

	[Import("Amsi.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern HRESULT AmsiOpenSession(HAMSICONTEXT amsiContext, HAMSISESSION* amsiSession);

	[Import("Amsi.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern void AmsiCloseSession(HAMSICONTEXT amsiContext, HAMSISESSION amsiSession);

	[Import("Amsi.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern HRESULT AmsiScanBuffer(HAMSICONTEXT amsiContext, void* buffer, uint32 length, PWSTR contentName, HAMSISESSION amsiSession, AMSI_RESULT* result);

	[Import("Amsi.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern HRESULT AmsiNotifyOperation(HAMSICONTEXT amsiContext, void* buffer, uint32 length, PWSTR contentName, AMSI_RESULT* result);

	[Import("Amsi.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern HRESULT AmsiScanString(HAMSICONTEXT amsiContext, PWSTR string, PWSTR contentName, HAMSISESSION amsiSession, AMSI_RESULT* result);

	[Import("KERNEL32.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern BOOL InstallELAMCertificateInfo(HANDLE ELAMFile);

}
#endregion
