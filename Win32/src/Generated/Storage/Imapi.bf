using Win32.Foundation;
using Win32.System.Com;
using Win32.System.Ole;
using Win32.System.Com.StructuredStorage;
using Win32.System.AddressBook;
using System;

namespace Win32.Storage.Imapi;

#region Constants
public static
{
	public const uint32 IMAPI_SECTOR_SIZE = 2048;
	public const uint32 IMAPI2_DEFAULT_COMMAND_TIMEOUT = 10;
	public const uint32 DISPID_DDISCMASTER2EVENTS_DEVICEADDED = 256;
	public const uint32 DISPID_DDISCMASTER2EVENTS_DEVICEREMOVED = 257;
	public const uint32 DISPID_IDISCRECORDER2_EJECTMEDIA = 256;
	public const uint32 DISPID_IDISCRECORDER2_CLOSETRAY = 257;
	public const uint32 DISPID_IDISCRECORDER2_ACQUIREEXCLUSIVEACCESS = 258;
	public const uint32 DISPID_IDISCRECORDER2_RELEASEEXCLUSIVEACCESS = 259;
	public const uint32 DISPID_IDISCRECORDER2_DISABLEMCN = 260;
	public const uint32 DISPID_IDISCRECORDER2_ENABLEMCN = 261;
	public const uint32 DISPID_IDISCRECORDER2_INITIALIZEDISCRECORDER = 262;
	public const uint32 DISPID_IDISCRECORDER2_ACTIVEDISCRECORDER = 0;
	public const uint32 DISPID_IDISCRECORDER2_VENDORID = 513;
	public const uint32 DISPID_IDISCRECORDER2_PRODUCTID = 514;
	public const uint32 DISPID_IDISCRECORDER2_PRODUCTREVISION = 515;
	public const uint32 DISPID_IDISCRECORDER2_VOLUMENAME = 516;
	public const uint32 DISPID_IDISCRECORDER2_VOLUMEPATHNAMES = 517;
	public const uint32 DISPID_IDISCRECORDER2_DEVICECANLOADMEDIA = 518;
	public const uint32 DISPID_IDISCRECORDER2_LEGACYDEVICENUMBER = 519;
	public const uint32 DISPID_IDISCRECORDER2_SUPPORTEDFEATUREPAGES = 520;
	public const uint32 DISPID_IDISCRECORDER2_CURRENTFEATUREPAGES = 521;
	public const uint32 DISPID_IDISCRECORDER2_SUPPORTEDPROFILES = 522;
	public const uint32 DISPID_IDISCRECORDER2_CURRENTPROFILES = 523;
	public const uint32 DISPID_IDISCRECORDER2_SUPPORTEDMODEPAGES = 524;
	public const uint32 DISPID_IDISCRECORDER2_EXCLUSIVEACCESSOWNER = 525;
	public const uint32 DISPID_IWRITEENGINE2_WRITESECTION = 512;
	public const uint32 DISPID_IWRITEENGINE2_CANCELWRITE = 513;
	public const uint32 DISPID_IWRITEENGINE2_DISCRECORDER = 256;
	public const uint32 DISPID_IWRITEENGINE2_USESTREAMINGWRITE12 = 257;
	public const uint32 DISPID_IWRITEENGINE2_STARTINGSECTORSPERSECOND = 258;
	public const uint32 DISPID_IWRITEENGINE2_ENDINGSECTORSPERSECOND = 259;
	public const uint32 DISPID_IWRITEENGINE2_BYTESPERSECTOR = 260;
	public const uint32 DISPID_IWRITEENGINE2_WRITEINPROGRESS = 261;
	public const uint32 DISPID_IWRITEENGINE2EVENTARGS_STARTLBA = 256;
	public const uint32 DISPID_IWRITEENGINE2EVENTARGS_SECTORCOUNT = 257;
	public const uint32 DISPID_IWRITEENGINE2EVENTARGS_LASTREADLBA = 258;
	public const uint32 DISPID_IWRITEENGINE2EVENTARGS_LASTWRITTENLBA = 259;
	public const uint32 DISPID_IWRITEENGINE2EVENTARGS_TOTALDEVICEBUFFER = 260;
	public const uint32 DISPID_IWRITEENGINE2EVENTARGS_USEDDEVICEBUFFER = 261;
	public const uint32 DISPID_IWRITEENGINE2EVENTARGS_TOTALSYSTEMBUFFER = 262;
	public const uint32 DISPID_IWRITEENGINE2EVENTARGS_USEDSYSTEMBUFFER = 263;
	public const uint32 DISPID_IWRITEENGINE2EVENTARGS_FREESYSTEMBUFFER = 264;
	public const uint32 DISPID_DWRITEENGINE2EVENTS_UPDATE = 256;
	public const uint32 DISPID_IDISCFORMAT2_RECORDERSUPPORTED = 2048;
	public const uint32 DISPID_IDISCFORMAT2_MEDIASUPPORTED = 2049;
	public const uint32 DISPID_IDISCFORMAT2_MEDIAPHYSICALLYBLANK = 1792;
	public const uint32 DISPID_IDISCFORMAT2_MEDIAHEURISTICALLYBLANK = 1793;
	public const uint32 DISPID_IDISCFORMAT2_SUPPORTEDMEDIATYPES = 1794;
	public const uint32 DISPID_IDISCFORMAT2ERASE_RECORDER = 256;
	public const uint32 DISPID_IDISCFORMAT2ERASE_FULLERASE = 257;
	public const uint32 DISPID_IDISCFORMAT2ERASE_MEDIATYPE = 258;
	public const uint32 DISPID_IDISCFORMAT2ERASE_CLIENTNAME = 259;
	public const uint32 DISPID_IDISCFORMAT2ERASE_ERASEMEDIA = 513;
	public const uint32 DISPID_IDISCFORMAT2ERASEEVENTS_UPDATE = 512;
	public const uint32 DISPID_IDISCFORMAT2DATA_RECORDER = 256;
	public const uint32 DISPID_IDISCFORMAT2DATA_BUFFERUNDERRUNFREEDISABLED = 257;
	public const uint32 DISPID_IDISCFORMAT2DATA_POSTGAPALREADYINIMAGE = 260;
	public const uint32 DISPID_IDISCFORMAT2DATA_CURRENTMEDIASTATUS = 262;
	public const uint32 DISPID_IDISCFORMAT2DATA_WRITEPROTECTSTATUS = 263;
	public const uint32 DISPID_IDISCFORMAT2DATA_TOTALSECTORS = 264;
	public const uint32 DISPID_IDISCFORMAT2DATA_FREESECTORS = 265;
	public const uint32 DISPID_IDISCFORMAT2DATA_NEXTWRITABLEADDRESS = 266;
	public const uint32 DISPID_IDISCFORMAT2DATA_STARTSECTOROFPREVIOUSSESSION = 267;
	public const uint32 DISPID_IDISCFORMAT2DATA_LASTSECTOROFPREVIOUSSESSION = 268;
	public const uint32 DISPID_IDISCFORMAT2DATA_FORCEMEDIATOBECLOSED = 269;
	public const uint32 DISPID_IDISCFORMAT2DATA_DISABLEDVDCOMPATIBILITYMODE = 270;
	public const uint32 DISPID_IDISCFORMAT2DATA_CURRENTMEDIATYPE = 271;
	public const uint32 DISPID_IDISCFORMAT2DATA_CLIENTNAME = 272;
	public const uint32 DISPID_IDISCFORMAT2DATA_REQUESTEDWRITESPEED = 273;
	public const uint32 DISPID_IDISCFORMAT2DATA_REQUESTEDROTATIONTYPEISPURECAV = 274;
	public const uint32 DISPID_IDISCFORMAT2DATA_CURRENTWRITESPEED = 275;
	public const uint32 DISPID_IDISCFORMAT2DATA_CURRENTROTATIONTYPEISPURECAV = 276;
	public const uint32 DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDS = 277;
	public const uint32 DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDDESCRIPTORS = 278;
	public const uint32 DISPID_IDISCFORMAT2DATA_FORCEOVERWRITE = 279;
	public const uint32 DISPID_IDISCFORMAT2DATA_MUTLISESSIONINTERFACES = 280;
	public const uint32 DISPID_IDISCFORMAT2DATA_WRITE = 512;
	public const uint32 DISPID_IDISCFORMAT2DATA_CANCELWRITE = 513;
	public const uint32 DISPID_IDISCFORMAT2DATA_SETWRITESPEED = 514;
	public const uint32 DISPID_DDISCFORMAT2DATAEVENTS_UPDATE = 512;
	public const uint32 DISPID_IDISCFORMAT2DATAEVENTARGS_ELAPSEDTIME = 768;
	public const uint32 DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDREMAININGTIME = 769;
	public const uint32 DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDTOTALTIME = 770;
	public const uint32 DISPID_IDISCFORMAT2DATAEVENTARGS_CURRENTACTION = 771;
	public const uint32 DISPID_IDISCFORMAT2TAO_RECORDER = 256;
	public const uint32 DISPID_IDISCFORMAT2TAO_BUFFERUNDERRUNFREEDISABLED = 258;
	public const uint32 DISPID_IDISCFORMAT2TAO_NUMBEROFEXISTINGTRACKS = 259;
	public const uint32 DISPID_IDISCFORMAT2TAO_TOTALSECTORSONMEDIA = 260;
	public const uint32 DISPID_IDISCFORMAT2TAO_FREESECTORSONMEDIA = 261;
	public const uint32 DISPID_IDISCFORMAT2TAO_USEDSECTORSONMEDIA = 262;
	public const uint32 DISPID_IDISCFORMAT2TAO_DONOTFINALIZEMEDIA = 263;
	public const uint32 DISPID_IDISCFORMAT2TAO_EXPECTEDTABLEOFCONTENTS = 266;
	public const uint32 DISPID_IDISCFORMAT2TAO_CURRENTMEDIATYPE = 267;
	public const uint32 DISPID_IDISCFORMAT2TAO_CLIENTNAME = 270;
	public const uint32 DISPID_IDISCFORMAT2TAO_REQUESTEDWRITESPEED = 271;
	public const uint32 DISPID_IDISCFORMAT2TAO_REQUESTEDROTATIONTYPEISPURECAV = 272;
	public const uint32 DISPID_IDISCFORMAT2TAO_CURRENTWRITESPEED = 273;
	public const uint32 DISPID_IDISCFORMAT2TAO_CURRENTROTATIONTYPEISPURECAV = 274;
	public const uint32 DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDS = 275;
	public const uint32 DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDDESCRIPTORS = 276;
	public const uint32 DISPID_IDISCFORMAT2TAO_PREPAREMEDIA = 512;
	public const uint32 DISPID_IDISCFORMAT2TAO_ADDAUDIOTRACK = 513;
	public const uint32 DISPID_IDISCFORMAT2TAO_CANCELADDTRACK = 514;
	public const uint32 DISPID_IDISCFORMAT2TAO_FINISHMEDIA = 515;
	public const uint32 DISPID_IDISCFORMAT2TAO_SETWRITESPEED = 516;
	public const uint32 DISPID_DDISCFORMAT2TAOEVENTS_UPDATE = 512;
	public const uint32 DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTTRACKNUMBER = 768;
	public const uint32 DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTACTION = 769;
	public const uint32 DISPID_IDISCFORMAT2TAOEVENTARGS_ELAPSEDTIME = 770;
	public const uint32 DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDREMAININGTIME = 771;
	public const uint32 DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDTOTALTIME = 772;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_RECORDER = 256;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_BUFFERUNDERRUNFREEDISABLED = 258;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_STARTOFNEXTSESSION = 259;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_LASTPOSSIBLESTARTOFLEADOUT = 260;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_CURRENTMEDIATYPE = 261;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_SUPPORTEDDATASECTORTYPES = 264;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_REQUESTEDDATASECTORTYPE = 265;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_CLIENTNAME = 266;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_REQUESTEDWRITESPEED = 267;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_REQUESTEDROTATIONTYPEISPURECAV = 268;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_CURRENTWRITESPEED = 269;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_CURRENTROTATIONTYPEISPURECAV = 270;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDS = 271;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDDESCRIPTORS = 272;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_PREPAREMEDIA = 512;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_WRITEMEDIA = 513;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_WRITEMEDIAWITHVALIDATION = 514;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_CANCELWRITE = 515;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_RELEASEMEDIA = 516;
	public const uint32 DISPID_IDISCFORMAT2RAWCD_SETWRITESPEED = 517;
	public const uint32 DISPID_DDISCFORMAT2RAWCDEVENTS_UPDATE = 512;
	public const uint32 DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTTRACKNUMBER = 768;
	public const uint32 DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTACTION = 769;
	public const uint32 DISPID_IDISCFORMAT2RAWCDEVENTARGS_ELAPSEDTIME = 768;
	public const uint32 DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDREMAININGTIME = 769;
	public const uint32 DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDTOTALTIME = 770;
	public const uint32 IMAPI_SECTORS_PER_SECOND_AT_1X_CD = 75;
	public const uint32 IMAPI_SECTORS_PER_SECOND_AT_1X_DVD = 680;
	public const uint32 IMAPI_SECTORS_PER_SECOND_AT_1X_BD = 2195;
	public const uint32 IMAPI_SECTORS_PER_SECOND_AT_1X_HD_DVD = 4568;
	public const uint32 DISPID_IMULTISESSION_SUPPORTEDONCURRENTMEDIA = 256;
	public const uint32 DISPID_IMULTISESSION_INUSE = 257;
	public const uint32 DISPID_IMULTISESSION_IMPORTRECORDER = 258;
	public const uint32 DISPID_IMULTISESSION_FIRSTDATASESSION = 512;
	public const uint32 DISPID_IMULTISESSION_STARTSECTOROFPREVIOUSSESSION = 513;
	public const uint32 DISPID_IMULTISESSION_LASTSECTOROFPREVIOUSSESSION = 514;
	public const uint32 DISPID_IMULTISESSION_NEXTWRITABLEADDRESS = 515;
	public const uint32 DISPID_IMULTISESSION_FREESECTORS = 516;
	public const uint32 DISPID_IMULTISESSION_WRITEUNITSIZE = 517;
	public const uint32 DISPID_IMULTISESSION_LASTWRITTENADDRESS = 518;
	public const uint32 DISPID_IMULTISESSION_SECTORSONMEDIA = 519;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_CREATERESULTIMAGE = 512;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_ADDTRACK = 513;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_ADDSPECIALPREGAP = 514;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_ADDSUBCODERWGENERATOR = 515;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_RESULTINGIMAGETYPE = 256;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUT = 257;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUTLIMIT = 258;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_DISABLEGAPLESSAUDIO = 259;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_MEDIACATALOGNUMBER = 260;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_STARTINGTRACKNUMBER = 261;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_TRACKINFO = 262;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_NUMBEROFEXISTINGTRACKS = 263;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_USEDSECTORSONDISC = 264;
	public const uint32 DISPID_IRAWCDIMAGECREATOR_EXPECTEDTABLEOFCONTENTS = 265;
	public const uint32 DISPID_IRAWCDTRACKINFO_STARTINGLBA = 256;
	public const uint32 DISPID_IRAWCDTRACKINFO_SECTORCOUNT = 257;
	public const uint32 DISPID_IRAWCDTRACKINFO_TRACKNUMBER = 258;
	public const uint32 DISPID_IRAWCDTRACKINFO_SECTORTYPE = 259;
	public const uint32 DISPID_IRAWCDTRACKINFO_ISRC = 260;
	public const uint32 DISPID_IRAWCDTRACKINFO_DIGITALAUDIOCOPYSETTING = 261;
	public const uint32 DISPID_IRAWCDTRACKINFO_AUDIOHASPREEMPHASIS = 262;
	public const uint32 DISPID_IBLOCKRANGE_STARTLBA = 256;
	public const uint32 DISPID_IBLOCKRANGE_ENDLBA = 257;
	public const uint32 DISPID_IBLOCKRANGELIST_BLOCKRANGES = 256;
	public const uint32 IMAPILib2_MajorVersion = 1;
	public const uint32 IMAPILib2_MinorVersion = 0;
	public const uint32 IMAPI2FS_BOOT_ENTRY_COUNT_MAX = 32;
	public const uint32 DISPID_DFILESYSTEMIMAGEEVENTS_UPDATE = 256;
	public const uint32 DISPID_DFILESYSTEMIMAGEIMPORTEVENTS_UPDATEIMPORT = 257;
	public const uint32 IMAPI2FS_MajorVersion = 1;
	public const uint32 IMAPI2FS_MinorVersion = 0;
	public const String IMAPI2FS_FullVersion_STR = "1.0";
	public const String IMAPI2FS_FullVersion_WSTR = "1.0";
	public const uint32 MP_MSGCLASS_SYSTEM = 1;
	public const uint32 MP_MSGCLASS_REPLICATION = 2;
	public const uint32 MP_MSGCLASS_DELIVERY_REPORT = 3;
	public const uint32 MP_MSGCLASS_NONDELIVERY_REPORT = 4;
	public const uint32 MP_STATUS_SUCCESS = 0;
	public const uint32 MP_STATUS_RETRY = 1;
	public const uint32 MP_STATUS_ABORT_DELIVERY = 2;
	public const uint32 MP_STATUS_BAD_MAIL = 3;
	public const uint32 MP_STATUS_SUBMITTED = 4;
	public const uint32 MP_STATUS_CATEGORIZED = 5;
	public const uint32 MP_STATUS_ABANDON_DELIVERY = 6;
	public const uint32 RP_RECIP_FLAGS_RESERVED = 15;
	public const uint32 RP_DSN_NOTIFY_SUCCESS = 16777216;
	public const uint32 RP_DSN_NOTIFY_FAILURE = 33554432;
	public const uint32 RP_DSN_NOTIFY_DELAY = 67108864;
	public const uint32 RP_DSN_NOTIFY_NEVER = 134217728;
	public const uint32 RP_DSN_NOTIFY_MASK = 251658240;
	public const uint32 RP_HANDLED = 16;
	public const uint32 RP_GENERAL_FAILURE = 32;
	public const uint32 RP_DSN_HANDLED = 64;
	public const uint32 RP_DELIVERED = 272;
	public const uint32 RP_DSN_SENT_NDR = 1104;
	public const uint32 RP_FAILED = 2096;
	public const uint32 RP_UNRESOLVED = 4144;
	public const uint32 RP_ENPANDED = 8208;
	public const uint32 RP_EXPANDED = 8208;
	public const uint32 RP_DSN_SENT_DELAYED = 16384;
	public const uint32 RP_DSN_SENT_EXPANDED = 32832;
	public const uint32 RP_DSN_SENT_RELAYED = 65600;
	public const uint32 RP_DSN_SENT_DELIVERED = 131136;
	public const uint32 RP_REMOTE_MTA_NO_DSN = 524288;
	public const uint32 RP_ERROR_CONTEXT_STORE = 1048576;
	public const uint32 RP_ERROR_CONTEXT_CAT = 2097152;
	public const uint32 RP_ERROR_CONTEXT_MTA = 4194304;
	public const uint32 RP_VOLATILE_FLAGS_MASK = 4026531840;
	public const uint32 RP_DSN_NOTIFY_INVALID = 0;
	public const uint32 MPV_INBOUND_CUTOFF_EXCEEDED = 1;
	public const uint32 MPV_WRITE_CONTENT = 2;
	public const uint32 NMP_PROCESS_POST = 1;
	public const uint32 NMP_PROCESS_CONTROL = 2;
	public const uint32 NMP_PROCESS_MODERATOR = 4;
	public const Guid GUID_SMTP_SOURCE_TYPE = .(0xfb65c4dc, 0xe468, 0x11d1, 0xaa, 0x67, 0x00, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);
	public const Guid GUID_SMTPSVC_SOURCE = .(0x1b3c0666, 0xe470, 0x11d1, 0xaa, 0x67, 0x00, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);
	public const Guid CATID_SMTP_ON_INBOUND_COMMAND = .(0xf6628c8d, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
	public const Guid CATID_SMTP_ON_SERVER_RESPONSE = .(0xf6628c8e, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
	public const Guid CATID_SMTP_ON_SESSION_START = .(0xf6628c8f, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
	public const Guid CATID_SMTP_ON_MESSAGE_START = .(0xf6628c90, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
	public const Guid CATID_SMTP_ON_PER_RECIPIENT = .(0xf6628c91, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
	public const Guid CATID_SMTP_ON_BEFORE_DATA = .(0xf6628c92, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
	public const Guid CATID_SMTP_ON_SESSION_END = .(0xf6628c93, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
	public const Guid CATID_SMTP_STORE_DRIVER = .(0x59175850, 0xe533, 0x11d1, 0xaa, 0x67, 0x00, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);
	public const Guid CATID_SMTP_TRANSPORT_SUBMISSION = .(0xff3caa23, 0x00b9, 0x11d2, 0x9d, 0xfb, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
	public const Guid CATID_SMTP_TRANSPORT_PRECATEGORIZE = .(0xa3acfb0d, 0x83ff, 0x11d2, 0x9e, 0x14, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
	public const Guid CATID_SMTP_TRANSPORT_CATEGORIZE = .(0x960252a3, 0x0a3a, 0x11d2, 0x9e, 0x00, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
	public const Guid CATID_SMTP_TRANSPORT_POSTCATEGORIZE = .(0x76719654, 0x05a6, 0x11d2, 0x9d, 0xfd, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
	public const Guid CATID_SMTP_TRANSPORT_ROUTER = .(0x283430c9, 0x1850, 0x11d2, 0x9e, 0x03, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
	public const Guid CATID_SMTP_MSGTRACKLOG = .(0xc6df52aa, 0x7db0, 0x11d2, 0x94, 0xf4, 0x00, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);
	public const Guid CATID_SMTP_DNSRESOLVERRECORDSINK = .(0xbd0b4366, 0x8e03, 0x11d2, 0x94, 0xf6, 0x00, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);
	public const Guid CATID_SMTP_MAXMSGSIZE = .(0xebf159de, 0xa67e, 0x11d2, 0x94, 0xf7, 0x00, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);
	public const Guid CATID_SMTP_LOG = .(0x93d0a538, 0x2c1e, 0x4b68, 0xa7, 0xc9, 0xd7, 0x3a, 0x8a, 0xa6, 0xee, 0x97);
	public const Guid CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS = .(0x84ff368a, 0xfab3, 0x43d7, 0xbc, 0xdf, 0x69, 0x2c, 0x5b, 0x46, 0xe6, 0xb1);
	public const Guid CLSID_SmtpCat = .(0xb23c35b7, 0x9219, 0x11d2, 0x9e, 0x17, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
	public const Guid CATID_SMTP_DSN = .(0x22b55731, 0xf5f8, 0x4d23, 0xbd, 0x8f, 0x87, 0xb5, 0x23, 0x71, 0xa7, 0x3a);
	public const String SZ_PROGID_SMTPCAT = "Smtp.Cat";
	public const HRESULT IMAPI_S_PROPERTIESIGNORED = 262656;
	public const HRESULT IMAPI_S_BUFFER_TO_SMALL = 262657;
	public const HRESULT IMAPI_E_NOTOPENED = -2147220981;
	public const HRESULT IMAPI_E_NOTINITIALIZED = -2147220980;
	public const HRESULT IMAPI_E_USERABORT = -2147220979;
	public const HRESULT IMAPI_E_GENERIC = -2147220978;
	public const HRESULT IMAPI_E_MEDIUM_NOTPRESENT = -2147220977;
	public const HRESULT IMAPI_E_MEDIUM_INVALIDTYPE = -2147220976;
	public const HRESULT IMAPI_E_DEVICE_NOPROPERTIES = -2147220975;
	public const HRESULT IMAPI_E_DEVICE_NOTACCESSIBLE = -2147220974;
	public const HRESULT IMAPI_E_DEVICE_NOTPRESENT = -2147220973;
	public const HRESULT IMAPI_E_DEVICE_INVALIDTYPE = -2147220972;
	public const HRESULT IMAPI_E_INITIALIZE_WRITE = -2147220971;
	public const HRESULT IMAPI_E_INITIALIZE_ENDWRITE = -2147220970;
	public const HRESULT IMAPI_E_FILESYSTEM = -2147220969;
	public const HRESULT IMAPI_E_FILEACCESS = -2147220968;
	public const HRESULT IMAPI_E_DISCINFO = -2147220967;
	public const HRESULT IMAPI_E_TRACKNOTOPEN = -2147220966;
	public const HRESULT IMAPI_E_TRACKOPEN = -2147220965;
	public const HRESULT IMAPI_E_DISCFULL = -2147220964;
	public const HRESULT IMAPI_E_BADJOLIETNAME = -2147220963;
	public const HRESULT IMAPI_E_INVALIDIMAGE = -2147220962;
	public const HRESULT IMAPI_E_NOACTIVEFORMAT = -2147220961;
	public const HRESULT IMAPI_E_NOACTIVERECORDER = -2147220960;
	public const HRESULT IMAPI_E_WRONGFORMAT = -2147220959;
	public const HRESULT IMAPI_E_ALREADYOPEN = -2147220958;
	public const HRESULT IMAPI_E_WRONGDISC = -2147220957;
	public const HRESULT IMAPI_E_FILEEXISTS = -2147220956;
	public const HRESULT IMAPI_E_STASHINUSE = -2147220955;
	public const HRESULT IMAPI_E_DEVICE_STILL_IN_USE = -2147220954;
	public const HRESULT IMAPI_E_LOSS_OF_STREAMING = -2147220953;
	public const HRESULT IMAPI_E_COMPRESSEDSTASH = -2147220952;
	public const HRESULT IMAPI_E_ENCRYPTEDSTASH = -2147220951;
	public const HRESULT IMAPI_E_NOTENOUGHDISKFORSTASH = -2147220950;
	public const HRESULT IMAPI_E_REMOVABLESTASH = -2147220949;
	public const HRESULT IMAPI_E_CANNOT_WRITE_TO_MEDIA = -2147220948;
	public const HRESULT IMAPI_E_TRACK_NOT_BIG_ENOUGH = -2147220947;
	public const HRESULT IMAPI_E_BOOTIMAGE_AND_NONBLANK_DISC = -2147220946;
}
#endregion

#region Enums

[AllowDuplicates]
public enum DISC_RECORDER_STATE_FLAGS : uint32
{
	RECORDER_BURNING = 2,
	RECORDER_DOING_NOTHING = 0,
	RECORDER_OPENED = 1,
}


[AllowDuplicates]
public enum IMAPI_MEDIA_PHYSICAL_TYPE : int32
{
	IMAPI_MEDIA_TYPE_UNKNOWN = 0,
	IMAPI_MEDIA_TYPE_CDROM = 1,
	IMAPI_MEDIA_TYPE_CDR = 2,
	IMAPI_MEDIA_TYPE_CDRW = 3,
	IMAPI_MEDIA_TYPE_DVDROM = 4,
	IMAPI_MEDIA_TYPE_DVDRAM = 5,
	IMAPI_MEDIA_TYPE_DVDPLUSR = 6,
	IMAPI_MEDIA_TYPE_DVDPLUSRW = 7,
	IMAPI_MEDIA_TYPE_DVDPLUSR_DUALLAYER = 8,
	IMAPI_MEDIA_TYPE_DVDDASHR = 9,
	IMAPI_MEDIA_TYPE_DVDDASHRW = 10,
	IMAPI_MEDIA_TYPE_DVDDASHR_DUALLAYER = 11,
	IMAPI_MEDIA_TYPE_DISK = 12,
	IMAPI_MEDIA_TYPE_DVDPLUSRW_DUALLAYER = 13,
	IMAPI_MEDIA_TYPE_HDDVDROM = 14,
	IMAPI_MEDIA_TYPE_HDDVDR = 15,
	IMAPI_MEDIA_TYPE_HDDVDRAM = 16,
	IMAPI_MEDIA_TYPE_BDROM = 17,
	IMAPI_MEDIA_TYPE_BDR = 18,
	IMAPI_MEDIA_TYPE_BDRE = 19,
	IMAPI_MEDIA_TYPE_MAX = 19,
}


[AllowDuplicates]
public enum IMAPI_MEDIA_WRITE_PROTECT_STATE : int32
{
	IMAPI_WRITEPROTECTED_UNTIL_POWERDOWN = 1,
	IMAPI_WRITEPROTECTED_BY_CARTRIDGE = 2,
	IMAPI_WRITEPROTECTED_BY_MEDIA_SPECIFIC_REASON = 4,
	IMAPI_WRITEPROTECTED_BY_SOFTWARE_WRITE_PROTECT = 8,
	IMAPI_WRITEPROTECTED_BY_DISC_CONTROL_BLOCK = 16,
	IMAPI_WRITEPROTECTED_READ_ONLY_MEDIA = 16384,
}


[AllowDuplicates]
public enum IMAPI_READ_TRACK_ADDRESS_TYPE : int32
{
	IMAPI_READ_TRACK_ADDRESS_TYPE_LBA = 0,
	IMAPI_READ_TRACK_ADDRESS_TYPE_TRACK = 1,
	IMAPI_READ_TRACK_ADDRESS_TYPE_SESSION = 2,
}


[AllowDuplicates]
public enum IMAPI_MODE_PAGE_REQUEST_TYPE : int32
{
	IMAPI_MODE_PAGE_REQUEST_TYPE_CURRENT_VALUES = 0,
	IMAPI_MODE_PAGE_REQUEST_TYPE_CHANGEABLE_VALUES = 1,
	IMAPI_MODE_PAGE_REQUEST_TYPE_DEFAULT_VALUES = 2,
	IMAPI_MODE_PAGE_REQUEST_TYPE_SAVED_VALUES = 3,
}


[AllowDuplicates]
public enum IMAPI_MODE_PAGE_TYPE : int32
{
	IMAPI_MODE_PAGE_TYPE_READ_WRITE_ERROR_RECOVERY = 1,
	IMAPI_MODE_PAGE_TYPE_MRW = 3,
	IMAPI_MODE_PAGE_TYPE_WRITE_PARAMETERS = 5,
	IMAPI_MODE_PAGE_TYPE_CACHING = 8,
	IMAPI_MODE_PAGE_TYPE_INFORMATIONAL_EXCEPTIONS = 28,
	IMAPI_MODE_PAGE_TYPE_TIMEOUT_AND_PROTECT = 29,
	IMAPI_MODE_PAGE_TYPE_POWER_CONDITION = 26,
	IMAPI_MODE_PAGE_TYPE_LEGACY_CAPABILITIES = 42,
}


[AllowDuplicates]
public enum IMAPI_FEATURE_PAGE_TYPE : int32
{
	IMAPI_FEATURE_PAGE_TYPE_PROFILE_LIST = 0,
	IMAPI_FEATURE_PAGE_TYPE_CORE = 1,
	IMAPI_FEATURE_PAGE_TYPE_MORPHING = 2,
	IMAPI_FEATURE_PAGE_TYPE_REMOVABLE_MEDIUM = 3,
	IMAPI_FEATURE_PAGE_TYPE_WRITE_PROTECT = 4,
	IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_READABLE = 16,
	IMAPI_FEATURE_PAGE_TYPE_CD_MULTIREAD = 29,
	IMAPI_FEATURE_PAGE_TYPE_CD_READ = 30,
	IMAPI_FEATURE_PAGE_TYPE_DVD_READ = 31,
	IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_WRITABLE = 32,
	IMAPI_FEATURE_PAGE_TYPE_INCREMENTAL_STREAMING_WRITABLE = 33,
	IMAPI_FEATURE_PAGE_TYPE_SECTOR_ERASABLE = 34,
	IMAPI_FEATURE_PAGE_TYPE_FORMATTABLE = 35,
	IMAPI_FEATURE_PAGE_TYPE_HARDWARE_DEFECT_MANAGEMENT = 36,
	IMAPI_FEATURE_PAGE_TYPE_WRITE_ONCE = 37,
	IMAPI_FEATURE_PAGE_TYPE_RESTRICTED_OVERWRITE = 38,
	IMAPI_FEATURE_PAGE_TYPE_CDRW_CAV_WRITE = 39,
	IMAPI_FEATURE_PAGE_TYPE_MRW = 40,
	IMAPI_FEATURE_PAGE_TYPE_ENHANCED_DEFECT_REPORTING = 41,
	IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_RW = 42,
	IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R = 43,
	IMAPI_FEATURE_PAGE_TYPE_RIGID_RESTRICTED_OVERWRITE = 44,
	IMAPI_FEATURE_PAGE_TYPE_CD_TRACK_AT_ONCE = 45,
	IMAPI_FEATURE_PAGE_TYPE_CD_MASTERING = 46,
	IMAPI_FEATURE_PAGE_TYPE_DVD_DASH_WRITE = 47,
	IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_READ = 48,
	IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_R_WRITE = 49,
	IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_RW_WRITE = 50,
	IMAPI_FEATURE_PAGE_TYPE_LAYER_JUMP_RECORDING = 51,
	IMAPI_FEATURE_PAGE_TYPE_CD_RW_MEDIA_WRITE_SUPPORT = 55,
	IMAPI_FEATURE_PAGE_TYPE_BD_PSEUDO_OVERWRITE = 56,
	IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R_DUAL_LAYER = 59,
	IMAPI_FEATURE_PAGE_TYPE_BD_READ = 64,
	IMAPI_FEATURE_PAGE_TYPE_BD_WRITE = 65,
	IMAPI_FEATURE_PAGE_TYPE_HD_DVD_READ = 80,
	IMAPI_FEATURE_PAGE_TYPE_HD_DVD_WRITE = 81,
	IMAPI_FEATURE_PAGE_TYPE_POWER_MANAGEMENT = 256,
	IMAPI_FEATURE_PAGE_TYPE_SMART = 257,
	IMAPI_FEATURE_PAGE_TYPE_EMBEDDED_CHANGER = 258,
	IMAPI_FEATURE_PAGE_TYPE_CD_ANALOG_PLAY = 259,
	IMAPI_FEATURE_PAGE_TYPE_MICROCODE_UPDATE = 260,
	IMAPI_FEATURE_PAGE_TYPE_TIMEOUT = 261,
	IMAPI_FEATURE_PAGE_TYPE_DVD_CSS = 262,
	IMAPI_FEATURE_PAGE_TYPE_REAL_TIME_STREAMING = 263,
	IMAPI_FEATURE_PAGE_TYPE_LOGICAL_UNIT_SERIAL_NUMBER = 264,
	IMAPI_FEATURE_PAGE_TYPE_MEDIA_SERIAL_NUMBER = 265,
	IMAPI_FEATURE_PAGE_TYPE_DISC_CONTROL_BLOCKS = 266,
	IMAPI_FEATURE_PAGE_TYPE_DVD_CPRM = 267,
	IMAPI_FEATURE_PAGE_TYPE_FIRMWARE_INFORMATION = 268,
	IMAPI_FEATURE_PAGE_TYPE_AACS = 269,
	IMAPI_FEATURE_PAGE_TYPE_VCPS = 272,
}


[AllowDuplicates]
public enum IMAPI_PROFILE_TYPE : int32
{
	IMAPI_PROFILE_TYPE_INVALID = 0,
	IMAPI_PROFILE_TYPE_NON_REMOVABLE_DISK = 1,
	IMAPI_PROFILE_TYPE_REMOVABLE_DISK = 2,
	IMAPI_PROFILE_TYPE_MO_ERASABLE = 3,
	IMAPI_PROFILE_TYPE_MO_WRITE_ONCE = 4,
	IMAPI_PROFILE_TYPE_AS_MO = 5,
	IMAPI_PROFILE_TYPE_CDROM = 8,
	IMAPI_PROFILE_TYPE_CD_RECORDABLE = 9,
	IMAPI_PROFILE_TYPE_CD_REWRITABLE = 10,
	IMAPI_PROFILE_TYPE_DVDROM = 16,
	IMAPI_PROFILE_TYPE_DVD_DASH_RECORDABLE = 17,
	IMAPI_PROFILE_TYPE_DVD_RAM = 18,
	IMAPI_PROFILE_TYPE_DVD_DASH_REWRITABLE = 19,
	IMAPI_PROFILE_TYPE_DVD_DASH_RW_SEQUENTIAL = 20,
	IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_SEQUENTIAL = 21,
	IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_LAYER_JUMP = 22,
	IMAPI_PROFILE_TYPE_DVD_PLUS_RW = 26,
	IMAPI_PROFILE_TYPE_DVD_PLUS_R = 27,
	IMAPI_PROFILE_TYPE_DDCDROM = 32,
	IMAPI_PROFILE_TYPE_DDCD_RECORDABLE = 33,
	IMAPI_PROFILE_TYPE_DDCD_REWRITABLE = 34,
	IMAPI_PROFILE_TYPE_DVD_PLUS_RW_DUAL = 42,
	IMAPI_PROFILE_TYPE_DVD_PLUS_R_DUAL = 43,
	IMAPI_PROFILE_TYPE_BD_ROM = 64,
	IMAPI_PROFILE_TYPE_BD_R_SEQUENTIAL = 65,
	IMAPI_PROFILE_TYPE_BD_R_RANDOM_RECORDING = 66,
	IMAPI_PROFILE_TYPE_BD_REWRITABLE = 67,
	IMAPI_PROFILE_TYPE_HD_DVD_ROM = 80,
	IMAPI_PROFILE_TYPE_HD_DVD_RECORDABLE = 81,
	IMAPI_PROFILE_TYPE_HD_DVD_RAM = 82,
	IMAPI_PROFILE_TYPE_NON_STANDARD = 65535,
}


[AllowDuplicates]
public enum IMAPI_FORMAT2_DATA_WRITE_ACTION : int32
{
	IMAPI_FORMAT2_DATA_WRITE_ACTION_VALIDATING_MEDIA = 0,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_FORMATTING_MEDIA = 1,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_INITIALIZING_HARDWARE = 2,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_CALIBRATING_POWER = 3,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_WRITING_DATA = 4,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_FINALIZATION = 5,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_COMPLETED = 6,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_VERIFYING = 7,
}


[AllowDuplicates]
public enum IMAPI_FORMAT2_DATA_MEDIA_STATE : int32
{
	IMAPI_FORMAT2_DATA_MEDIA_STATE_UNKNOWN = 0,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_INFORMATIONAL_MASK = 15,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MASK = 64512,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_OVERWRITE_ONLY = 1,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_RANDOMLY_WRITABLE = 1,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_BLANK = 2,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_APPENDABLE = 4,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_FINAL_SESSION = 8,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_DAMAGED = 1024,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_ERASE_REQUIRED = 2048,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_NON_EMPTY_SESSION = 4096,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_WRITE_PROTECTED = 8192,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_FINALIZED = 16384,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MEDIA = 32768,
}


[AllowDuplicates]
public enum IMAPI_FORMAT2_TAO_WRITE_ACTION : int32
{
	IMAPI_FORMAT2_TAO_WRITE_ACTION_UNKNOWN = 0,
	IMAPI_FORMAT2_TAO_WRITE_ACTION_PREPARING = 1,
	IMAPI_FORMAT2_TAO_WRITE_ACTION_WRITING = 2,
	IMAPI_FORMAT2_TAO_WRITE_ACTION_FINISHING = 3,
	IMAPI_FORMAT2_TAO_WRITE_ACTION_VERIFYING = 4,
}


[AllowDuplicates]
public enum IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE : int32
{
	IMAPI_FORMAT2_RAW_CD_SUBCODE_PQ_ONLY = 1,
	IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_COOKED = 2,
	IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_RAW = 3,
}


[AllowDuplicates]
public enum IMAPI_FORMAT2_RAW_CD_WRITE_ACTION : int32
{
	IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_UNKNOWN = 0,
	IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_PREPARING = 1,
	IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_WRITING = 2,
	IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_FINISHING = 3,
}


[AllowDuplicates]
public enum IMAPI_CD_SECTOR_TYPE : int32
{
	IMAPI_CD_SECTOR_AUDIO = 0,
	IMAPI_CD_SECTOR_MODE_ZERO = 1,
	IMAPI_CD_SECTOR_MODE1 = 2,
	IMAPI_CD_SECTOR_MODE2FORM0 = 3,
	IMAPI_CD_SECTOR_MODE2FORM1 = 4,
	IMAPI_CD_SECTOR_MODE2FORM2 = 5,
	IMAPI_CD_SECTOR_MODE1RAW = 6,
	IMAPI_CD_SECTOR_MODE2FORM0RAW = 7,
	IMAPI_CD_SECTOR_MODE2FORM1RAW = 8,
	IMAPI_CD_SECTOR_MODE2FORM2RAW = 9,
}


[AllowDuplicates]
public enum IMAPI_CD_TRACK_DIGITAL_COPY_SETTING : int32
{
	IMAPI_CD_TRACK_DIGITAL_COPY_PERMITTED = 0,
	IMAPI_CD_TRACK_DIGITAL_COPY_PROHIBITED = 1,
	IMAPI_CD_TRACK_DIGITAL_COPY_SCMS = 2,
}


[AllowDuplicates]
public enum IMAPI_BURN_VERIFICATION_LEVEL : int32
{
	IMAPI_BURN_VERIFICATION_NONE = 0,
	IMAPI_BURN_VERIFICATION_QUICK = 1,
	IMAPI_BURN_VERIFICATION_FULL = 2,
}


[AllowDuplicates]
public enum FsiItemType : int32
{
	FsiItemNotFound = 0,
	FsiItemDirectory = 1,
	FsiItemFile = 2,
}


[AllowDuplicates]
public enum FsiFileSystems : int32
{
	FsiFileSystemNone = 0,
	FsiFileSystemISO9660 = 1,
	FsiFileSystemJoliet = 2,
	FsiFileSystemUDF = 4,
	FsiFileSystemUnknown = 1073741824,
}


[AllowDuplicates]
public enum EmulationType : int32
{
	EmulationNone = 0,
	Emulation12MFloppy = 1,
	Emulation144MFloppy = 2,
	Emulation288MFloppy = 3,
	EmulationHardDisk = 4,
}


[AllowDuplicates]
public enum PlatformId : int32
{
	PlatformX86 = 0,
	PlatformPowerPC = 1,
	PlatformMac = 2,
	PlatformEFI = 239,
}


[AllowDuplicates]
public enum MEDIA_TYPES : int32
{
	MEDIA_CDDA_CDROM = 1,
	MEDIA_CD_ROM_XA = 2,
	MEDIA_CD_I = 3,
	MEDIA_CD_EXTRA = 4,
	MEDIA_CD_OTHER = 5,
	MEDIA_SPECIAL = 6,
}


[AllowDuplicates]
public enum MEDIA_FLAGS : int32
{
	MEDIA_BLANK = 1,
	MEDIA_RW = 2,
	MEDIA_WRITABLE = 4,
	MEDIA_FORMAT_UNUSABLE_BY_IMAPI = 8,
}


[AllowDuplicates]
public enum RECORDER_TYPES : int32
{
	RECORDER_CDR = 1,
	RECORDER_CDRW = 2,
}


[AllowDuplicates]
public enum IMMPID_MP_ENUM : int32
{
	IMMPID_MP_BEFORE__ = 4095,
	IMMPID_MP_RECIPIENT_LIST = 4096,
	IMMPID_MP_CONTENT_FILE_NAME = 4097,
	IMMPID_MP_SENDER_ADDRESS_SMTP = 4098,
	IMMPID_MP_SENDER_ADDRESS_X500 = 4099,
	IMMPID_MP_SENDER_ADDRESS_X400 = 4100,
	IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN = 4101,
	IMMPID_MP_DOMAIN_LIST = 4102,
	IMMPID_MP_PICKUP_FILE_NAME = 4103,
	IMMPID_MP_AUTHENTICATED_USER_NAME = 4104,
	IMMPID_MP_CONNECTION_IP_ADDRESS = 4105,
	IMMPID_MP_HELO_DOMAIN = 4106,
	IMMPID_MP_EIGHTBIT_MIME_OPTION = 4107,
	IMMPID_MP_CHUNKING_OPTION = 4108,
	IMMPID_MP_BINARYMIME_OPTION = 4109,
	IMMPID_MP_REMOTE_AUTHENTICATION_TYPE = 4110,
	IMMPID_MP_ERROR_CODE = 4111,
	IMMPID_MP_DSN_ENVID_VALUE = 4112,
	IMMPID_MP_DSN_RET_VALUE = 4113,
	IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE = 4114,
	IMMPID_MP_ARRIVAL_TIME = 4115,
	IMMPID_MP_MESSAGE_STATUS = 4116,
	IMMPID_MP_EXPIRE_DELAY = 4117,
	IMMPID_MP_EXPIRE_NDR = 4118,
	IMMPID_MP_LOCAL_EXPIRE_DELAY = 4119,
	IMMPID_MP_LOCAL_EXPIRE_NDR = 4120,
	IMMPID_MP_ARRIVAL_FILETIME = 4121,
	IMMPID_MP_HR_CAT_STATUS = 4122,
	IMMPID_MP_MSG_GUID = 4123,
	IMMPID_MP_SUPERSEDES_MSG_GUID = 4124,
	IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF = 4125,
	IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF = 4126,
	IMMPID_MP_MSG_SIZE_HINT = 4127,
	IMMPID_MP_RFC822_MSG_ID = 4128,
	IMMPID_MP_RFC822_MSG_SUBJECT = 4129,
	IMMPID_MP_RFC822_FROM_ADDRESS = 4130,
	IMMPID_MP_RFC822_TO_ADDRESS = 4131,
	IMMPID_MP_RFC822_CC_ADDRESS = 4132,
	IMMPID_MP_RFC822_BCC_ADDRESS = 4133,
	IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS = 4134,
	IMMPID_MP_SERVER_NAME = 4135,
	IMMPID_MP_SERVER_VERSION = 4136,
	IMMPID_MP_NUM_RECIPIENTS = 4137,
	IMMPID_MP_X_PRIORITY = 4138,
	IMMPID_MP_FROM_ADDRESS = 4139,
	IMMPID_MP_SENDER_ADDRESS = 4140,
	IMMPID_MP_DEFERRED_DELIVERY_FILETIME = 4141,
	IMMPID_MP_SENDER_ADDRESS_OTHER = 4142,
	IMMPID_MP_ORIGINAL_ARRIVAL_TIME = 4143,
	IMMPID_MP_MSGCLASS = 4144,
	IMMPID_MP_CONTENT_TYPE = 4145,
	IMMPID_MP_ENCRYPTION_TYPE = 4146,
	IMMPID_MP_CONNECTION_SERVER_PORT = 4147,
	IMMPID_MP_CLIENT_AUTH_USER = 4148,
	IMMPID_MP_CLIENT_AUTH_TYPE = 4149,
	IMMPID_MP_CRC_GLOBAL = 4150,
	IMMPID_MP_CRC_RECIPS = 4151,
	IMMPID_MP_INBOUND_MAIL_FROM_AUTH = 4152,
	IMMPID_MP_AFTER__ = 4153,
}


[AllowDuplicates]
public enum IMMPID_RP_ENUM : int32
{
	IMMPID_RP_BEFORE__ = 8191,
	IMMPID_RP_DSN_NOTIFY_SUCCESS = 8192,
	IMMPID_RP_DSN_NOTIFY_INVALID = 8193,
	IMMPID_RP_ADDRESS_TYPE = 8194,
	IMMPID_RP_ADDRESS = 8195,
	IMMPID_RP_ADDRESS_TYPE_SMTP = 8196,
	IMMPID_RP_ERROR_CODE = 8197,
	IMMPID_RP_ERROR_STRING = 8198,
	IMMPID_RP_DSN_NOTIFY_VALUE = 8199,
	IMMPID_RP_DSN_ORCPT_VALUE = 8200,
	IMMPID_RP_ADDRESS_SMTP = 8201,
	IMMPID_RP_ADDRESS_X400 = 8202,
	IMMPID_RP_ADDRESS_X500 = 8203,
	IMMPID_RP_LEGACY_EX_DN = 8204,
	IMMPID_RP_RECIPIENT_FLAGS = 8205,
	IMMPID_RP_SMTP_STATUS_STRING = 8206,
	IMMPID_RP_DSN_PRE_CAT_ADDRESS = 8207,
	IMMPID_RP_MDB_GUID = 8208,
	IMMPID_RP_USER_GUID = 8209,
	IMMPID_RP_DOMAIN = 8210,
	IMMPID_RP_ADDRESS_OTHER = 8211,
	IMMPID_RP_DISPLAY_NAME = 8212,
	IMMPID_RP_AFTER__ = 8213,
}


[AllowDuplicates]
public enum IMMPID_MPV_ENUM : int32
{
	IMMPID_MPV_BEFORE__ = 12287,
	IMMPID_MPV_STORE_DRIVER_HANDLE = 12288,
	IMMPID_MPV_MESSAGE_CREATION_FLAGS = 12289,
	IMMPID_MPV_MESSAGE_OPEN_HANDLES = 12290,
	IMMPID_MPV_TOTAL_OPEN_HANDLES = 12291,
	IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES = 12292,
	IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES = 12293,
	IMMPID_MPV_AFTER__ = 12294,
}


[AllowDuplicates]
public enum IMMPID_RPV_ENUM : int32
{
	IMMPID_RPV_BEFORE__ = 16383,
	IMMPID_RPV_DONT_DELIVER = 16384,
	IMMPID_RPV_NO_NAME_COLLISIONS = 16385,
	IMMPID_RPV_AFTER__ = 16386,
}


[AllowDuplicates]
public enum IMMPID_NMP_ENUM : int32
{
	IMMPID_NMP_BEFORE__ = 24575,
	IMMPID_NMP_SECONDARY_GROUPS = 24576,
	IMMPID_NMP_SECONDARY_ARTNUM = 24577,
	IMMPID_NMP_PRIMARY_GROUP = 24578,
	IMMPID_NMP_PRIMARY_ARTID = 24579,
	IMMPID_NMP_POST_TOKEN = 24580,
	IMMPID_NMP_NEWSGROUP_LIST = 24581,
	IMMPID_NMP_HEADERS = 24582,
	IMMPID_NMP_NNTP_PROCESSING = 24583,
	IMMPID_NMP_NNTP_APPROVED_HEADER = 24584,
	IMMPID_NMP_AFTER__ = 24585,
}


[AllowDuplicates]
public enum IMMPID_CPV_ENUM : int32
{
	IMMPID_CPV_BEFORE__ = 32767,
	IMMPID_CP_START = 32768,
	IMMPID_CPV_AFTER__ = 32769,
}

#endregion

#region Function Pointers
public function void MSGCALLRELEASE(uint32 ulCallerData, IMessage* lpMessage);

#endregion

#region Structs
[CRepr]
public struct _MSGSESS
{
}

[CRepr]
public struct SPropAttrArray
{
	public uint32 cValues;
	public uint32* aPropAttr mut => &aPropAttr_impl;
	private uint32[ANYSIZE_ARRAY] aPropAttr_impl;
}

[CRepr]
public struct IMMP_MPV_STORE_DRIVER_HANDLE
{
	public Guid guidSignature;
}

[CRepr]
public struct tagIMMPID_GUIDLIST_ITEM
{
	public Guid* pguid;
	public uint32 dwStart;
	public uint32 dwLast;
}

#endregion

#region COM Class IDs
public static
{
	public const Guid CLSID_MsftDiscMaster2 = .(0x2735412e, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftDiscRecorder2 = .(0x2735412d, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftWriteEngine2 = .(0x2735412c, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftDiscFormat2Erase = .(0x2735412b, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftDiscFormat2Data = .(0x2735412a, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftDiscFormat2TrackAtOnce = .(0x27354129, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftDiscFormat2RawCD = .(0x27354128, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftStreamZero = .(0x27354127, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftStreamPrng001 = .(0x27354126, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftStreamConcatenate = .(0x27354125, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftStreamInterleave = .(0x27354124, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftWriteSpeedDescriptor = .(0x27354123, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftMultisessionSequential = .(0x27354122, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);


	public const Guid CLSID_MsftMultisessionRandomWrite = .(0xb507ca24, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);


	public const Guid CLSID_MsftRawCDImageCreator = .(0x25983561, 0x9d65, 0x49ce, 0xb3, 0x35, 0x40, 0x63, 0x0d, 0x90, 0x12, 0x27);


	public const Guid CLSID_BootOptions = .(0x2c941fce, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);


	public const Guid CLSID_FsiStream = .(0x2c941fcd, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);


	public const Guid CLSID_FileSystemImageResult = .(0x2c941fcc, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);


	public const Guid CLSID_ProgressItem = .(0x2c941fcb, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);


	public const Guid CLSID_EnumProgressItems = .(0x2c941fca, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);


	public const Guid CLSID_ProgressItems = .(0x2c941fc9, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);


	public const Guid CLSID_FsiDirectoryItem = .(0x2c941fc8, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);


	public const Guid CLSID_FsiFileItem = .(0x2c941fc7, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);


	public const Guid CLSID_EnumFsiItems = .(0x2c941fc6, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);


	public const Guid CLSID_FsiNamedStreams = .(0xc6b6f8ed, 0x6d19, 0x44b4, 0xb5, 0x39, 0xb1, 0x59, 0xb7, 0x93, 0xa3, 0x2d);


	public const Guid CLSID_MsftFileSystemImage = .(0x2c941fc5, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);


	public const Guid CLSID_MsftIsoImageManager = .(0xceee3b62, 0x8f56, 0x4056, 0x86, 0x9b, 0xef, 0x16, 0x91, 0x7e, 0x3e, 0xfc);


	public const Guid CLSID_BlockRange = .(0xb507ca27, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);


	public const Guid CLSID_BlockRangeList = .(0xb507ca28, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);


	public const Guid CLSID_MSDiscRecorderObj = .(0x520cca61, 0x51a5, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);


	public const Guid CLSID_MSDiscMasterObj = .(0x520cca63, 0x51a5, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);


	public const Guid CLSID_MSEnumDiscRecordersObj = .(0x8a03567a, 0x63cb, 0x4ba8, 0xba, 0xf6, 0x52, 0x11, 0x98, 0x16, 0xd1, 0xef);


	public const Guid CLSID_tagIMMPID_MP_STRUCT = .(0x13384cf0, 0xb3c4, 0x11d1, 0xaa, 0x92, 0x00, 0xaa, 0x00, 0x6b, 0xc8, 0x0b);


	public const Guid CLSID_tagIMMPID_RP_STRUCT = .(0x79e82048, 0xd320, 0x11d1, 0x9f, 0xf4, 0x00, 0xc0, 0x4f, 0xa3, 0x73, 0x48);


	public const Guid CLSID_tagIMMPID_MPV_STRUCT = .(0xcbe69706, 0xc9bd, 0x11d1, 0x9f, 0xf2, 0x00, 0xc0, 0x4f, 0xa3, 0x73, 0x48);


	public const Guid CLSID_tagIMMPID_RPV_STRUCT = .(0x79e82049, 0xd320, 0x11d1, 0x9f, 0xf4, 0x00, 0xc0, 0x4f, 0xa3, 0x73, 0x48);


	public const Guid CLSID_tagIMMPID_NMP_STRUCT = .(0x7433a9aa, 0x20e2, 0x11d2, 0x94, 0xd6, 0x00, 0xc0, 0x4f, 0xa3, 0x79, 0xf1);


	public const Guid CLSID_tagIMMPID_CPV_STRUCT = .(0xa2a76b2a, 0xe52d, 0x11d1, 0xaa, 0x64, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);


}
#endregion

#region COM Types
[CRepr]struct IDiscMaster2 : IDispatch
{
	public new const Guid IID = .(0x27354130, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumVARIANT** ppunk) get__NewEnum;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 index, BSTR* value) get_Item;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_Count;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_IsSupportedEnvironment;
	}


	public HRESULT get__NewEnum(IEnumVARIANT** ppunk) mut => VT.[Friend]get__NewEnum(&this, ppunk);

	public HRESULT get_Item(int32 index, BSTR* value) mut => VT.[Friend]get_Item(&this, index, value);

	public HRESULT get_Count(int32* value) mut => VT.[Friend]get_Count(&this, value);

	public HRESULT get_IsSupportedEnvironment(int16* value) mut => VT.[Friend]get_IsSupportedEnvironment(&this, value);
}

[CRepr]struct DDiscMaster2Events : IDispatch
{
	public new const Guid IID = .(0x27354131, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDispatch* object, BSTR uniqueId) NotifyDeviceAdded;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDispatch* object, BSTR uniqueId) NotifyDeviceRemoved;
	}


	public HRESULT NotifyDeviceAdded(IDispatch* object, BSTR uniqueId) mut => VT.[Friend]NotifyDeviceAdded(&this, object, uniqueId);

	public HRESULT NotifyDeviceRemoved(IDispatch* object, BSTR uniqueId) mut => VT.[Friend]NotifyDeviceRemoved(&this, object, uniqueId);
}

[CRepr]struct IDiscRecorder2Ex : IUnknown
{
	public new const Guid IID = .(0x27354132, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8* Cdb, uint32 CdbSize, uint8* SenseBuffer, uint32 Timeout) SendCommandNoData;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8* Cdb, uint32 CdbSize, uint8* SenseBuffer, uint32 Timeout, uint8* Buffer, uint32 BufferSize) SendCommandSendDataToDevice;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8* Cdb, uint32 CdbSize, uint8* SenseBuffer, uint32 Timeout, uint8* Buffer, uint32 BufferSize, uint32* BufferFetched) SendCommandGetDataFromDevice;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 format, uint32 address, uint32 layer, uint32 agid, uint8** data, uint32* count) ReadDvdStructure;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 format, uint8* data, uint32 count) SendDvdStructure;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8** data, uint32* byteSize) GetAdapterDescriptor;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8** data, uint32* byteSize) GetDeviceDescriptor;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8** discInformation, uint32* byteSize) GetDiscInformation;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 address, IMAPI_READ_TRACK_ADDRESS_TYPE addressType, uint8** trackInformation, uint32* byteSize) GetTrackInformation;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_FEATURE_PAGE_TYPE requestedFeature, BOOLEAN currentFeatureOnly, uint8** featureData, uint32* byteSize) GetFeaturePage;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_MODE_PAGE_TYPE requestedModePage, IMAPI_MODE_PAGE_REQUEST_TYPE requestType, uint8** modePageData, uint32* byteSize) GetModePage;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_MODE_PAGE_REQUEST_TYPE requestType, uint8* data, uint32 byteSize) SetModePage;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BOOLEAN currentFeatureOnly, IMAPI_FEATURE_PAGE_TYPE** featureData, uint32* byteSize) GetSupportedFeaturePages;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BOOLEAN currentOnly, IMAPI_PROFILE_TYPE** profileTypes, uint32* validProfiles) GetSupportedProfiles;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_MODE_PAGE_REQUEST_TYPE requestType, IMAPI_MODE_PAGE_TYPE** modePageTypes, uint32* validPages) GetSupportedModePages;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32* value) GetByteAlignmentMask;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32* value) GetMaximumNonPageAlignedTransferSize;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32* value) GetMaximumPageAlignedTransferSize;
	}


	public HRESULT SendCommandNoData(uint8* Cdb, uint32 CdbSize, uint8* SenseBuffer, uint32 Timeout) mut => VT.[Friend]SendCommandNoData(&this, Cdb, CdbSize, SenseBuffer, Timeout);

	public HRESULT SendCommandSendDataToDevice(uint8* Cdb, uint32 CdbSize, uint8* SenseBuffer, uint32 Timeout, uint8* Buffer, uint32 BufferSize) mut => VT.[Friend]SendCommandSendDataToDevice(&this, Cdb, CdbSize, SenseBuffer, Timeout, Buffer, BufferSize);

	public HRESULT SendCommandGetDataFromDevice(uint8* Cdb, uint32 CdbSize, uint8* SenseBuffer, uint32 Timeout, uint8* Buffer, uint32 BufferSize, uint32* BufferFetched) mut => VT.[Friend]SendCommandGetDataFromDevice(&this, Cdb, CdbSize, SenseBuffer, Timeout, Buffer, BufferSize, BufferFetched);

	public HRESULT ReadDvdStructure(uint32 format, uint32 address, uint32 layer, uint32 agid, uint8** data, uint32* count) mut => VT.[Friend]ReadDvdStructure(&this, format, address, layer, agid, data, count);

	public HRESULT SendDvdStructure(uint32 format, uint8* data, uint32 count) mut => VT.[Friend]SendDvdStructure(&this, format, data, count);

	public HRESULT GetAdapterDescriptor(uint8** data, uint32* byteSize) mut => VT.[Friend]GetAdapterDescriptor(&this, data, byteSize);

	public HRESULT GetDeviceDescriptor(uint8** data, uint32* byteSize) mut => VT.[Friend]GetDeviceDescriptor(&this, data, byteSize);

	public HRESULT GetDiscInformation(uint8** discInformation, uint32* byteSize) mut => VT.[Friend]GetDiscInformation(&this, discInformation, byteSize);

	public HRESULT GetTrackInformation(uint32 address, IMAPI_READ_TRACK_ADDRESS_TYPE addressType, uint8** trackInformation, uint32* byteSize) mut => VT.[Friend]GetTrackInformation(&this, address, addressType, trackInformation, byteSize);

	public HRESULT GetFeaturePage(IMAPI_FEATURE_PAGE_TYPE requestedFeature, BOOLEAN currentFeatureOnly, uint8** featureData, uint32* byteSize) mut => VT.[Friend]GetFeaturePage(&this, requestedFeature, currentFeatureOnly, featureData, byteSize);

	public HRESULT GetModePage(IMAPI_MODE_PAGE_TYPE requestedModePage, IMAPI_MODE_PAGE_REQUEST_TYPE requestType, uint8** modePageData, uint32* byteSize) mut => VT.[Friend]GetModePage(&this, requestedModePage, requestType, modePageData, byteSize);

	public HRESULT SetModePage(IMAPI_MODE_PAGE_REQUEST_TYPE requestType, uint8* data, uint32 byteSize) mut => VT.[Friend]SetModePage(&this, requestType, data, byteSize);

	public HRESULT GetSupportedFeaturePages(BOOLEAN currentFeatureOnly, IMAPI_FEATURE_PAGE_TYPE** featureData, uint32* byteSize) mut => VT.[Friend]GetSupportedFeaturePages(&this, currentFeatureOnly, featureData, byteSize);

	public HRESULT GetSupportedProfiles(BOOLEAN currentOnly, IMAPI_PROFILE_TYPE** profileTypes, uint32* validProfiles) mut => VT.[Friend]GetSupportedProfiles(&this, currentOnly, profileTypes, validProfiles);

	public HRESULT GetSupportedModePages(IMAPI_MODE_PAGE_REQUEST_TYPE requestType, IMAPI_MODE_PAGE_TYPE** modePageTypes, uint32* validPages) mut => VT.[Friend]GetSupportedModePages(&this, requestType, modePageTypes, validPages);

	public HRESULT GetByteAlignmentMask(uint32* value) mut => VT.[Friend]GetByteAlignmentMask(&this, value);

	public HRESULT GetMaximumNonPageAlignedTransferSize(uint32* value) mut => VT.[Friend]GetMaximumNonPageAlignedTransferSize(&this, value);

	public HRESULT GetMaximumPageAlignedTransferSize(uint32* value) mut => VT.[Friend]GetMaximumPageAlignedTransferSize(&this, value);
}

[CRepr]struct IDiscRecorder2 : IDispatch
{
	public new const Guid IID = .(0x27354133, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) EjectMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) CloseTray;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 force, BSTR __MIDL__IDiscRecorder20000) AcquireExclusiveAccess;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) ReleaseExclusiveAccess;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) DisableMcn;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) EnableMcn;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR recorderUniqueId) InitializeDiscRecorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_ActiveDiscRecorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_VendorId;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_ProductId;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_ProductRevision;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_VolumeName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_VolumePathNames;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_DeviceCanLoadMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* legacyDeviceNumber) get_LegacyDeviceNumber;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_SupportedFeaturePages;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_CurrentFeaturePages;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_SupportedProfiles;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_CurrentProfiles;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_SupportedModePages;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_ExclusiveAccessOwner;
	}


	public HRESULT EjectMedia() mut => VT.[Friend]EjectMedia(&this);

	public HRESULT CloseTray() mut => VT.[Friend]CloseTray(&this);

	public HRESULT AcquireExclusiveAccess(int16 force, BSTR __MIDL__IDiscRecorder20000) mut => VT.[Friend]AcquireExclusiveAccess(&this, force, __MIDL__IDiscRecorder20000);

	public HRESULT ReleaseExclusiveAccess() mut => VT.[Friend]ReleaseExclusiveAccess(&this);

	public HRESULT DisableMcn() mut => VT.[Friend]DisableMcn(&this);

	public HRESULT EnableMcn() mut => VT.[Friend]EnableMcn(&this);

	public HRESULT InitializeDiscRecorder(BSTR recorderUniqueId) mut => VT.[Friend]InitializeDiscRecorder(&this, recorderUniqueId);

	public HRESULT get_ActiveDiscRecorder(BSTR* value) mut => VT.[Friend]get_ActiveDiscRecorder(&this, value);

	public HRESULT get_VendorId(BSTR* value) mut => VT.[Friend]get_VendorId(&this, value);

	public HRESULT get_ProductId(BSTR* value) mut => VT.[Friend]get_ProductId(&this, value);

	public HRESULT get_ProductRevision(BSTR* value) mut => VT.[Friend]get_ProductRevision(&this, value);

	public HRESULT get_VolumeName(BSTR* value) mut => VT.[Friend]get_VolumeName(&this, value);

	public HRESULT get_VolumePathNames(SAFEARRAY** value) mut => VT.[Friend]get_VolumePathNames(&this, value);

	public HRESULT get_DeviceCanLoadMedia(int16* value) mut => VT.[Friend]get_DeviceCanLoadMedia(&this, value);

	public HRESULT get_LegacyDeviceNumber(int32* legacyDeviceNumber) mut => VT.[Friend]get_LegacyDeviceNumber(&this, legacyDeviceNumber);

	public HRESULT get_SupportedFeaturePages(SAFEARRAY** value) mut => VT.[Friend]get_SupportedFeaturePages(&this, value);

	public HRESULT get_CurrentFeaturePages(SAFEARRAY** value) mut => VT.[Friend]get_CurrentFeaturePages(&this, value);

	public HRESULT get_SupportedProfiles(SAFEARRAY** value) mut => VT.[Friend]get_SupportedProfiles(&this, value);

	public HRESULT get_CurrentProfiles(SAFEARRAY** value) mut => VT.[Friend]get_CurrentProfiles(&this, value);

	public HRESULT get_SupportedModePages(SAFEARRAY** value) mut => VT.[Friend]get_SupportedModePages(&this, value);

	public HRESULT get_ExclusiveAccessOwner(BSTR* value) mut => VT.[Friend]get_ExclusiveAccessOwner(&this, value);
}

[CRepr]struct IWriteEngine2 : IDispatch
{
	public new const Guid IID = .(0x27354135, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* data, int32 startingBlockAddress, int32 numberOfBlocks) WriteSection;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) CancelWrite;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2Ex* value) put_Recorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2Ex** value) get_Recorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_UseStreamingWrite12;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_UseStreamingWrite12;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 value) put_StartingSectorsPerSecond;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_StartingSectorsPerSecond;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 value) put_EndingSectorsPerSecond;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_EndingSectorsPerSecond;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 value) put_BytesPerSector;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_BytesPerSector;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_WriteInProgress;
	}


	public HRESULT WriteSection(IStream* data, int32 startingBlockAddress, int32 numberOfBlocks) mut => VT.[Friend]WriteSection(&this, data, startingBlockAddress, numberOfBlocks);

	public HRESULT CancelWrite() mut => VT.[Friend]CancelWrite(&this);

	public HRESULT put_Recorder(IDiscRecorder2Ex* value) mut => VT.[Friend]put_Recorder(&this, value);

	public HRESULT get_Recorder(IDiscRecorder2Ex** value) mut => VT.[Friend]get_Recorder(&this, value);

	public HRESULT put_UseStreamingWrite12(int16 value) mut => VT.[Friend]put_UseStreamingWrite12(&this, value);

	public HRESULT get_UseStreamingWrite12(int16* value) mut => VT.[Friend]get_UseStreamingWrite12(&this, value);

	public HRESULT put_StartingSectorsPerSecond(int32 value) mut => VT.[Friend]put_StartingSectorsPerSecond(&this, value);

	public HRESULT get_StartingSectorsPerSecond(int32* value) mut => VT.[Friend]get_StartingSectorsPerSecond(&this, value);

	public HRESULT put_EndingSectorsPerSecond(int32 value) mut => VT.[Friend]put_EndingSectorsPerSecond(&this, value);

	public HRESULT get_EndingSectorsPerSecond(int32* value) mut => VT.[Friend]get_EndingSectorsPerSecond(&this, value);

	public HRESULT put_BytesPerSector(int32 value) mut => VT.[Friend]put_BytesPerSector(&this, value);

	public HRESULT get_BytesPerSector(int32* value) mut => VT.[Friend]get_BytesPerSector(&this, value);

	public HRESULT get_WriteInProgress(int16* value) mut => VT.[Friend]get_WriteInProgress(&this, value);
}

[CRepr]struct IWriteEngine2EventArgs : IDispatch
{
	public new const Guid IID = .(0x27354136, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_StartLba;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_SectorCount;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_LastReadLba;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_LastWrittenLba;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_TotalSystemBuffer;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_UsedSystemBuffer;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_FreeSystemBuffer;
	}


	public HRESULT get_StartLba(int32* value) mut => VT.[Friend]get_StartLba(&this, value);

	public HRESULT get_SectorCount(int32* value) mut => VT.[Friend]get_SectorCount(&this, value);

	public HRESULT get_LastReadLba(int32* value) mut => VT.[Friend]get_LastReadLba(&this, value);

	public HRESULT get_LastWrittenLba(int32* value) mut => VT.[Friend]get_LastWrittenLba(&this, value);

	public HRESULT get_TotalSystemBuffer(int32* value) mut => VT.[Friend]get_TotalSystemBuffer(&this, value);

	public HRESULT get_UsedSystemBuffer(int32* value) mut => VT.[Friend]get_UsedSystemBuffer(&this, value);

	public HRESULT get_FreeSystemBuffer(int32* value) mut => VT.[Friend]get_FreeSystemBuffer(&this, value);
}

[CRepr]struct DWriteEngine2Events : IDispatch
{
	public new const Guid IID = .(0x27354137, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDispatch* object, IDispatch* progress) Update;
	}


	public HRESULT Update(IDispatch* object, IDispatch* progress) mut => VT.[Friend]Update(&this, object, progress);
}

[CRepr]struct IDiscFormat2 : IDispatch
{
	public new const Guid IID = .(0x27354152, 0x8f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2* recorder, int16* value) IsRecorderSupported;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2* recorder, int16* value) IsCurrentMediaSupported;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_MediaPhysicallyBlank;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_MediaHeuristicallyBlank;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_SupportedMediaTypes;
	}


	public HRESULT IsRecorderSupported(IDiscRecorder2* recorder, int16* value) mut => VT.[Friend]IsRecorderSupported(&this, recorder, value);

	public HRESULT IsCurrentMediaSupported(IDiscRecorder2* recorder, int16* value) mut => VT.[Friend]IsCurrentMediaSupported(&this, recorder, value);

	public HRESULT get_MediaPhysicallyBlank(int16* value) mut => VT.[Friend]get_MediaPhysicallyBlank(&this, value);

	public HRESULT get_MediaHeuristicallyBlank(int16* value) mut => VT.[Friend]get_MediaHeuristicallyBlank(&this, value);

	public HRESULT get_SupportedMediaTypes(SAFEARRAY** value) mut => VT.[Friend]get_SupportedMediaTypes(&this, value);
}

[CRepr]struct IDiscFormat2Erase : IDiscFormat2
{
	public new const Guid IID = .(0x27354156, 0x8f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDiscFormat2.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2* value) put_Recorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2** value) get_Recorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_FullErase;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_FullErase;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_MEDIA_PHYSICAL_TYPE* value) get_CurrentPhysicalMediaType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR value) put_ClientName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_ClientName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) EraseMedia;
	}


	public HRESULT put_Recorder(IDiscRecorder2* value) mut => VT.[Friend]put_Recorder(&this, value);

	public HRESULT get_Recorder(IDiscRecorder2** value) mut => VT.[Friend]get_Recorder(&this, value);

	public HRESULT put_FullErase(int16 value) mut => VT.[Friend]put_FullErase(&this, value);

	public HRESULT get_FullErase(int16* value) mut => VT.[Friend]get_FullErase(&this, value);

	public HRESULT get_CurrentPhysicalMediaType(IMAPI_MEDIA_PHYSICAL_TYPE* value) mut => VT.[Friend]get_CurrentPhysicalMediaType(&this, value);

	public HRESULT put_ClientName(BSTR value) mut => VT.[Friend]put_ClientName(&this, value);

	public HRESULT get_ClientName(BSTR* value) mut => VT.[Friend]get_ClientName(&this, value);

	public HRESULT EraseMedia() mut => VT.[Friend]EraseMedia(&this);
}

[CRepr]struct DDiscFormat2EraseEvents : IDispatch
{
	public new const Guid IID = .(0x2735413a, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDispatch* object, int32 elapsedSeconds, int32 estimatedTotalSeconds) Update;
	}


	public HRESULT Update(IDispatch* object, int32 elapsedSeconds, int32 estimatedTotalSeconds) mut => VT.[Friend]Update(&this, object, elapsedSeconds, estimatedTotalSeconds);
}

[CRepr]struct IDiscFormat2Data : IDiscFormat2
{
	public new const Guid IID = .(0x27354153, 0x9f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDiscFormat2.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2* value) put_Recorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2** value) get_Recorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_BufferUnderrunFreeDisabled;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_BufferUnderrunFreeDisabled;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_PostgapAlreadyInImage;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_PostgapAlreadyInImage;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_FORMAT2_DATA_MEDIA_STATE* value) get_CurrentMediaStatus;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_MEDIA_WRITE_PROTECT_STATE* value) get_WriteProtectStatus;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_TotalSectorsOnMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_FreeSectorsOnMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_NextWritableAddress;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_StartAddressOfPreviousSession;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_LastWrittenAddressOfPreviousSession;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_ForceMediaToBeClosed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_ForceMediaToBeClosed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_DisableConsumerDvdCompatibilityMode;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_DisableConsumerDvdCompatibilityMode;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_MEDIA_PHYSICAL_TYPE* value) get_CurrentPhysicalMediaType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR value) put_ClientName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_ClientName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_RequestedWriteSpeed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_RequestedRotationTypeIsPureCAV;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_CurrentWriteSpeed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_CurrentRotationTypeIsPureCAV;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** supportedSpeeds) get_SupportedWriteSpeeds;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** supportedSpeedDescriptors) get_SupportedWriteSpeedDescriptors;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_ForceOverwrite;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_ForceOverwrite;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_MultisessionInterfaces;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* data) Write;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) CancelWrite;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 RequestedSectorsPerSecond, int16 RotationTypeIsPureCAV) SetWriteSpeed;
	}


	public HRESULT put_Recorder(IDiscRecorder2* value) mut => VT.[Friend]put_Recorder(&this, value);

	public HRESULT get_Recorder(IDiscRecorder2** value) mut => VT.[Friend]get_Recorder(&this, value);

	public HRESULT put_BufferUnderrunFreeDisabled(int16 value) mut => VT.[Friend]put_BufferUnderrunFreeDisabled(&this, value);

	public HRESULT get_BufferUnderrunFreeDisabled(int16* value) mut => VT.[Friend]get_BufferUnderrunFreeDisabled(&this, value);

	public HRESULT put_PostgapAlreadyInImage(int16 value) mut => VT.[Friend]put_PostgapAlreadyInImage(&this, value);

	public HRESULT get_PostgapAlreadyInImage(int16* value) mut => VT.[Friend]get_PostgapAlreadyInImage(&this, value);

	public HRESULT get_CurrentMediaStatus(IMAPI_FORMAT2_DATA_MEDIA_STATE* value) mut => VT.[Friend]get_CurrentMediaStatus(&this, value);

	public HRESULT get_WriteProtectStatus(IMAPI_MEDIA_WRITE_PROTECT_STATE* value) mut => VT.[Friend]get_WriteProtectStatus(&this, value);

	public HRESULT get_TotalSectorsOnMedia(int32* value) mut => VT.[Friend]get_TotalSectorsOnMedia(&this, value);

	public HRESULT get_FreeSectorsOnMedia(int32* value) mut => VT.[Friend]get_FreeSectorsOnMedia(&this, value);

	public HRESULT get_NextWritableAddress(int32* value) mut => VT.[Friend]get_NextWritableAddress(&this, value);

	public HRESULT get_StartAddressOfPreviousSession(int32* value) mut => VT.[Friend]get_StartAddressOfPreviousSession(&this, value);

	public HRESULT get_LastWrittenAddressOfPreviousSession(int32* value) mut => VT.[Friend]get_LastWrittenAddressOfPreviousSession(&this, value);

	public HRESULT put_ForceMediaToBeClosed(int16 value) mut => VT.[Friend]put_ForceMediaToBeClosed(&this, value);

	public HRESULT get_ForceMediaToBeClosed(int16* value) mut => VT.[Friend]get_ForceMediaToBeClosed(&this, value);

	public HRESULT put_DisableConsumerDvdCompatibilityMode(int16 value) mut => VT.[Friend]put_DisableConsumerDvdCompatibilityMode(&this, value);

	public HRESULT get_DisableConsumerDvdCompatibilityMode(int16* value) mut => VT.[Friend]get_DisableConsumerDvdCompatibilityMode(&this, value);

	public HRESULT get_CurrentPhysicalMediaType(IMAPI_MEDIA_PHYSICAL_TYPE* value) mut => VT.[Friend]get_CurrentPhysicalMediaType(&this, value);

	public HRESULT put_ClientName(BSTR value) mut => VT.[Friend]put_ClientName(&this, value);

	public HRESULT get_ClientName(BSTR* value) mut => VT.[Friend]get_ClientName(&this, value);

	public HRESULT get_RequestedWriteSpeed(int32* value) mut => VT.[Friend]get_RequestedWriteSpeed(&this, value);

	public HRESULT get_RequestedRotationTypeIsPureCAV(int16* value) mut => VT.[Friend]get_RequestedRotationTypeIsPureCAV(&this, value);

	public HRESULT get_CurrentWriteSpeed(int32* value) mut => VT.[Friend]get_CurrentWriteSpeed(&this, value);

	public HRESULT get_CurrentRotationTypeIsPureCAV(int16* value) mut => VT.[Friend]get_CurrentRotationTypeIsPureCAV(&this, value);

	public HRESULT get_SupportedWriteSpeeds(SAFEARRAY** supportedSpeeds) mut => VT.[Friend]get_SupportedWriteSpeeds(&this, supportedSpeeds);

	public HRESULT get_SupportedWriteSpeedDescriptors(SAFEARRAY** supportedSpeedDescriptors) mut => VT.[Friend]get_SupportedWriteSpeedDescriptors(&this, supportedSpeedDescriptors);

	public HRESULT put_ForceOverwrite(int16 value) mut => VT.[Friend]put_ForceOverwrite(&this, value);

	public HRESULT get_ForceOverwrite(int16* value) mut => VT.[Friend]get_ForceOverwrite(&this, value);

	public HRESULT get_MultisessionInterfaces(SAFEARRAY** value) mut => VT.[Friend]get_MultisessionInterfaces(&this, value);

	public HRESULT Write(IStream* data) mut => VT.[Friend]Write(&this, data);

	public HRESULT CancelWrite() mut => VT.[Friend]CancelWrite(&this);

	public HRESULT SetWriteSpeed(int32 RequestedSectorsPerSecond, int16 RotationTypeIsPureCAV) mut => VT.[Friend]SetWriteSpeed(&this, RequestedSectorsPerSecond, RotationTypeIsPureCAV);
}

[CRepr]struct DDiscFormat2DataEvents : IDispatch
{
	public new const Guid IID = .(0x2735413c, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDispatch* object, IDispatch* progress) Update;
	}


	public HRESULT Update(IDispatch* object, IDispatch* progress) mut => VT.[Friend]Update(&this, object, progress);
}

[CRepr]struct IDiscFormat2DataEventArgs : IWriteEngine2EventArgs
{
	public new const Guid IID = .(0x2735413d, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IWriteEngine2EventArgs.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_ElapsedTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_RemainingTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_TotalTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_FORMAT2_DATA_WRITE_ACTION* value) get_CurrentAction;
	}


	public HRESULT get_ElapsedTime(int32* value) mut => VT.[Friend]get_ElapsedTime(&this, value);

	public HRESULT get_RemainingTime(int32* value) mut => VT.[Friend]get_RemainingTime(&this, value);

	public HRESULT get_TotalTime(int32* value) mut => VT.[Friend]get_TotalTime(&this, value);

	public HRESULT get_CurrentAction(IMAPI_FORMAT2_DATA_WRITE_ACTION* value) mut => VT.[Friend]get_CurrentAction(&this, value);
}

[CRepr]struct IDiscFormat2TrackAtOnce : IDiscFormat2
{
	public new const Guid IID = .(0x27354154, 0x8f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDiscFormat2.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) PrepareMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* data) AddAudioTrack;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) CancelAddTrack;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) ReleaseMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 RequestedSectorsPerSecond, int16 RotationTypeIsPureCAV) SetWriteSpeed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2* value) put_Recorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2** value) get_Recorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_BufferUnderrunFreeDisabled;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_BufferUnderrunFreeDisabled;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_NumberOfExistingTracks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_TotalSectorsOnMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_FreeSectorsOnMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_UsedSectorsOnMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_DoNotFinalizeMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_DoNotFinalizeMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_ExpectedTableOfContents;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_MEDIA_PHYSICAL_TYPE* value) get_CurrentPhysicalMediaType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR value) put_ClientName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_ClientName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_RequestedWriteSpeed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_RequestedRotationTypeIsPureCAV;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_CurrentWriteSpeed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_CurrentRotationTypeIsPureCAV;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** supportedSpeeds) get_SupportedWriteSpeeds;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** supportedSpeedDescriptors) get_SupportedWriteSpeedDescriptors;
	}


	public HRESULT PrepareMedia() mut => VT.[Friend]PrepareMedia(&this);

	public HRESULT AddAudioTrack(IStream* data) mut => VT.[Friend]AddAudioTrack(&this, data);

	public HRESULT CancelAddTrack() mut => VT.[Friend]CancelAddTrack(&this);

	public HRESULT ReleaseMedia() mut => VT.[Friend]ReleaseMedia(&this);

	public HRESULT SetWriteSpeed(int32 RequestedSectorsPerSecond, int16 RotationTypeIsPureCAV) mut => VT.[Friend]SetWriteSpeed(&this, RequestedSectorsPerSecond, RotationTypeIsPureCAV);

	public HRESULT put_Recorder(IDiscRecorder2* value) mut => VT.[Friend]put_Recorder(&this, value);

	public HRESULT get_Recorder(IDiscRecorder2** value) mut => VT.[Friend]get_Recorder(&this, value);

	public HRESULT put_BufferUnderrunFreeDisabled(int16 value) mut => VT.[Friend]put_BufferUnderrunFreeDisabled(&this, value);

	public HRESULT get_BufferUnderrunFreeDisabled(int16* value) mut => VT.[Friend]get_BufferUnderrunFreeDisabled(&this, value);

	public HRESULT get_NumberOfExistingTracks(int32* value) mut => VT.[Friend]get_NumberOfExistingTracks(&this, value);

	public HRESULT get_TotalSectorsOnMedia(int32* value) mut => VT.[Friend]get_TotalSectorsOnMedia(&this, value);

	public HRESULT get_FreeSectorsOnMedia(int32* value) mut => VT.[Friend]get_FreeSectorsOnMedia(&this, value);

	public HRESULT get_UsedSectorsOnMedia(int32* value) mut => VT.[Friend]get_UsedSectorsOnMedia(&this, value);

	public HRESULT put_DoNotFinalizeMedia(int16 value) mut => VT.[Friend]put_DoNotFinalizeMedia(&this, value);

	public HRESULT get_DoNotFinalizeMedia(int16* value) mut => VT.[Friend]get_DoNotFinalizeMedia(&this, value);

	public HRESULT get_ExpectedTableOfContents(SAFEARRAY** value) mut => VT.[Friend]get_ExpectedTableOfContents(&this, value);

	public HRESULT get_CurrentPhysicalMediaType(IMAPI_MEDIA_PHYSICAL_TYPE* value) mut => VT.[Friend]get_CurrentPhysicalMediaType(&this, value);

	public HRESULT put_ClientName(BSTR value) mut => VT.[Friend]put_ClientName(&this, value);

	public HRESULT get_ClientName(BSTR* value) mut => VT.[Friend]get_ClientName(&this, value);

	public HRESULT get_RequestedWriteSpeed(int32* value) mut => VT.[Friend]get_RequestedWriteSpeed(&this, value);

	public HRESULT get_RequestedRotationTypeIsPureCAV(int16* value) mut => VT.[Friend]get_RequestedRotationTypeIsPureCAV(&this, value);

	public HRESULT get_CurrentWriteSpeed(int32* value) mut => VT.[Friend]get_CurrentWriteSpeed(&this, value);

	public HRESULT get_CurrentRotationTypeIsPureCAV(int16* value) mut => VT.[Friend]get_CurrentRotationTypeIsPureCAV(&this, value);

	public HRESULT get_SupportedWriteSpeeds(SAFEARRAY** supportedSpeeds) mut => VT.[Friend]get_SupportedWriteSpeeds(&this, supportedSpeeds);

	public HRESULT get_SupportedWriteSpeedDescriptors(SAFEARRAY** supportedSpeedDescriptors) mut => VT.[Friend]get_SupportedWriteSpeedDescriptors(&this, supportedSpeedDescriptors);
}

[CRepr]struct DDiscFormat2TrackAtOnceEvents : IDispatch
{
	public new const Guid IID = .(0x2735413f, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDispatch* object, IDispatch* progress) Update;
	}


	public HRESULT Update(IDispatch* object, IDispatch* progress) mut => VT.[Friend]Update(&this, object, progress);
}

[CRepr]struct IDiscFormat2TrackAtOnceEventArgs : IWriteEngine2EventArgs
{
	public new const Guid IID = .(0x27354140, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IWriteEngine2EventArgs.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_CurrentTrackNumber;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_FORMAT2_TAO_WRITE_ACTION* value) get_CurrentAction;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_ElapsedTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_RemainingTime;
	}


	public HRESULT get_CurrentTrackNumber(int32* value) mut => VT.[Friend]get_CurrentTrackNumber(&this, value);

	public HRESULT get_CurrentAction(IMAPI_FORMAT2_TAO_WRITE_ACTION* value) mut => VT.[Friend]get_CurrentAction(&this, value);

	public HRESULT get_ElapsedTime(int32* value) mut => VT.[Friend]get_ElapsedTime(&this, value);

	public HRESULT get_RemainingTime(int32* value) mut => VT.[Friend]get_RemainingTime(&this, value);
}

[CRepr]struct IDiscFormat2RawCD : IDiscFormat2
{
	public new const Guid IID = .(0x27354155, 0x8f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDiscFormat2.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) PrepareMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* data) WriteMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* data, int32 streamLeadInSectors) WriteMedia2;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) CancelWrite;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) ReleaseMedia;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 RequestedSectorsPerSecond, int16 RotationTypeIsPureCAV) SetWriteSpeed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2* value) put_Recorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2** value) get_Recorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_BufferUnderrunFreeDisabled;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_BufferUnderrunFreeDisabled;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_StartOfNextSession;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_LastPossibleStartOfLeadout;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_MEDIA_PHYSICAL_TYPE* value) get_CurrentPhysicalMediaType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_SupportedSectorTypes;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE value) put_RequestedSectorType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE* value) get_RequestedSectorType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR value) put_ClientName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_ClientName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_RequestedWriteSpeed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_RequestedRotationTypeIsPureCAV;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_CurrentWriteSpeed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_CurrentRotationTypeIsPureCAV;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** supportedSpeeds) get_SupportedWriteSpeeds;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** supportedSpeedDescriptors) get_SupportedWriteSpeedDescriptors;
	}


	public HRESULT PrepareMedia() mut => VT.[Friend]PrepareMedia(&this);

	public HRESULT WriteMedia(IStream* data) mut => VT.[Friend]WriteMedia(&this, data);

	public HRESULT WriteMedia2(IStream* data, int32 streamLeadInSectors) mut => VT.[Friend]WriteMedia2(&this, data, streamLeadInSectors);

	public HRESULT CancelWrite() mut => VT.[Friend]CancelWrite(&this);

	public HRESULT ReleaseMedia() mut => VT.[Friend]ReleaseMedia(&this);

	public HRESULT SetWriteSpeed(int32 RequestedSectorsPerSecond, int16 RotationTypeIsPureCAV) mut => VT.[Friend]SetWriteSpeed(&this, RequestedSectorsPerSecond, RotationTypeIsPureCAV);

	public HRESULT put_Recorder(IDiscRecorder2* value) mut => VT.[Friend]put_Recorder(&this, value);

	public HRESULT get_Recorder(IDiscRecorder2** value) mut => VT.[Friend]get_Recorder(&this, value);

	public HRESULT put_BufferUnderrunFreeDisabled(int16 value) mut => VT.[Friend]put_BufferUnderrunFreeDisabled(&this, value);

	public HRESULT get_BufferUnderrunFreeDisabled(int16* value) mut => VT.[Friend]get_BufferUnderrunFreeDisabled(&this, value);

	public HRESULT get_StartOfNextSession(int32* value) mut => VT.[Friend]get_StartOfNextSession(&this, value);

	public HRESULT get_LastPossibleStartOfLeadout(int32* value) mut => VT.[Friend]get_LastPossibleStartOfLeadout(&this, value);

	public HRESULT get_CurrentPhysicalMediaType(IMAPI_MEDIA_PHYSICAL_TYPE* value) mut => VT.[Friend]get_CurrentPhysicalMediaType(&this, value);

	public HRESULT get_SupportedSectorTypes(SAFEARRAY** value) mut => VT.[Friend]get_SupportedSectorTypes(&this, value);

	public HRESULT put_RequestedSectorType(IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE value) mut => VT.[Friend]put_RequestedSectorType(&this, value);

	public HRESULT get_RequestedSectorType(IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE* value) mut => VT.[Friend]get_RequestedSectorType(&this, value);

	public HRESULT put_ClientName(BSTR value) mut => VT.[Friend]put_ClientName(&this, value);

	public HRESULT get_ClientName(BSTR* value) mut => VT.[Friend]get_ClientName(&this, value);

	public HRESULT get_RequestedWriteSpeed(int32* value) mut => VT.[Friend]get_RequestedWriteSpeed(&this, value);

	public HRESULT get_RequestedRotationTypeIsPureCAV(int16* value) mut => VT.[Friend]get_RequestedRotationTypeIsPureCAV(&this, value);

	public HRESULT get_CurrentWriteSpeed(int32* value) mut => VT.[Friend]get_CurrentWriteSpeed(&this, value);

	public HRESULT get_CurrentRotationTypeIsPureCAV(int16* value) mut => VT.[Friend]get_CurrentRotationTypeIsPureCAV(&this, value);

	public HRESULT get_SupportedWriteSpeeds(SAFEARRAY** supportedSpeeds) mut => VT.[Friend]get_SupportedWriteSpeeds(&this, supportedSpeeds);

	public HRESULT get_SupportedWriteSpeedDescriptors(SAFEARRAY** supportedSpeedDescriptors) mut => VT.[Friend]get_SupportedWriteSpeedDescriptors(&this, supportedSpeedDescriptors);
}

[CRepr]struct DDiscFormat2RawCDEvents : IDispatch
{
	public new const Guid IID = .(0x27354142, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDispatch* object, IDispatch* progress) Update;
	}


	public HRESULT Update(IDispatch* object, IDispatch* progress) mut => VT.[Friend]Update(&this, object, progress);
}

[CRepr]struct IDiscFormat2RawCDEventArgs : IWriteEngine2EventArgs
{
	public new const Guid IID = .(0x27354143, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IWriteEngine2EventArgs.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_FORMAT2_RAW_CD_WRITE_ACTION* value) get_CurrentAction;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_ElapsedTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_RemainingTime;
	}


	public HRESULT get_CurrentAction(IMAPI_FORMAT2_RAW_CD_WRITE_ACTION* value) mut => VT.[Friend]get_CurrentAction(&this, value);

	public HRESULT get_ElapsedTime(int32* value) mut => VT.[Friend]get_ElapsedTime(&this, value);

	public HRESULT get_RemainingTime(int32* value) mut => VT.[Friend]get_RemainingTime(&this, value);
}

[CRepr]struct IBurnVerification : IUnknown
{
	public new const Guid IID = .(0xd2ffd834, 0x958b, 0x426d, 0x84, 0x70, 0x2a, 0x13, 0x87, 0x9c, 0x6a, 0x91);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_BURN_VERIFICATION_LEVEL value) put_BurnVerificationLevel;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_BURN_VERIFICATION_LEVEL* value) get_BurnVerificationLevel;
	}


	public HRESULT put_BurnVerificationLevel(IMAPI_BURN_VERIFICATION_LEVEL value) mut => VT.[Friend]put_BurnVerificationLevel(&this, value);

	public HRESULT get_BurnVerificationLevel(IMAPI_BURN_VERIFICATION_LEVEL* value) mut => VT.[Friend]get_BurnVerificationLevel(&this, value);
}

[CRepr]struct IWriteSpeedDescriptor : IDispatch
{
	public new const Guid IID = .(0x27354144, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_MEDIA_PHYSICAL_TYPE* value) get_MediaType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_RotationTypeIsPureCAV;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_WriteSpeed;
	}


	public HRESULT get_MediaType(IMAPI_MEDIA_PHYSICAL_TYPE* value) mut => VT.[Friend]get_MediaType(&this, value);

	public HRESULT get_RotationTypeIsPureCAV(int16* value) mut => VT.[Friend]get_RotationTypeIsPureCAV(&this, value);

	public HRESULT get_WriteSpeed(int32* value) mut => VT.[Friend]get_WriteSpeed(&this, value);
}

[CRepr]struct IMultisession : IDispatch
{
	public new const Guid IID = .(0x27354150, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_IsSupportedOnCurrentMediaState;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_InUse;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_InUse;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2** value) get_ImportRecorder;
	}


	public HRESULT get_IsSupportedOnCurrentMediaState(int16* value) mut => VT.[Friend]get_IsSupportedOnCurrentMediaState(&this, value);

	public HRESULT put_InUse(int16 value) mut => VT.[Friend]put_InUse(&this, value);

	public HRESULT get_InUse(int16* value) mut => VT.[Friend]get_InUse(&this, value);

	public HRESULT get_ImportRecorder(IDiscRecorder2** value) mut => VT.[Friend]get_ImportRecorder(&this, value);
}

[CRepr]struct IMultisessionSequential : IMultisession
{
	public new const Guid IID = .(0x27354151, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IMultisession.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_IsFirstDataSession;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_StartAddressOfPreviousSession;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_LastWrittenAddressOfPreviousSession;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_NextWritableAddress;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_FreeSectorsOnMedia;
	}


	public HRESULT get_IsFirstDataSession(int16* value) mut => VT.[Friend]get_IsFirstDataSession(&this, value);

	public HRESULT get_StartAddressOfPreviousSession(int32* value) mut => VT.[Friend]get_StartAddressOfPreviousSession(&this, value);

	public HRESULT get_LastWrittenAddressOfPreviousSession(int32* value) mut => VT.[Friend]get_LastWrittenAddressOfPreviousSession(&this, value);

	public HRESULT get_NextWritableAddress(int32* value) mut => VT.[Friend]get_NextWritableAddress(&this, value);

	public HRESULT get_FreeSectorsOnMedia(int32* value) mut => VT.[Friend]get_FreeSectorsOnMedia(&this, value);
}

[CRepr]struct IMultisessionSequential2 : IMultisessionSequential
{
	public new const Guid IID = .(0xb507ca22, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IMultisessionSequential.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_WriteUnitSize;
	}


	public HRESULT get_WriteUnitSize(int32* value) mut => VT.[Friend]get_WriteUnitSize(&this, value);
}

[CRepr]struct IMultisessionRandomWrite : IMultisession
{
	public new const Guid IID = .(0xb507ca23, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IMultisession.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_WriteUnitSize;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_LastWrittenAddress;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_TotalSectorsOnMedia;
	}


	public HRESULT get_WriteUnitSize(int32* value) mut => VT.[Friend]get_WriteUnitSize(&this, value);

	public HRESULT get_LastWrittenAddress(int32* value) mut => VT.[Friend]get_LastWrittenAddress(&this, value);

	public HRESULT get_TotalSectorsOnMedia(int32* value) mut => VT.[Friend]get_TotalSectorsOnMedia(&this, value);
}

[CRepr]struct IStreamPseudoRandomBased : IStream
{
	public new const Guid IID = .(0x27354145, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IStream.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 value) put_Seed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32* value) get_Seed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32* values, uint32 eCount) put_ExtendedSeed;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32** values, uint32* eCount) get_ExtendedSeed;
	}


	public HRESULT put_Seed(uint32 value) mut => VT.[Friend]put_Seed(&this, value);

	public HRESULT get_Seed(uint32* value) mut => VT.[Friend]get_Seed(&this, value);

	public HRESULT put_ExtendedSeed(uint32* values, uint32 eCount) mut => VT.[Friend]put_ExtendedSeed(&this, values, eCount);

	public HRESULT get_ExtendedSeed(uint32** values, uint32* eCount) mut => VT.[Friend]get_ExtendedSeed(&this, values, eCount);
}

[CRepr]struct IStreamConcatenate : IStream
{
	public new const Guid IID = .(0x27354146, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IStream.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* stream1, IStream* stream2) Initialize;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream** streams, uint32 streamCount) Initialize2;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* stream) Append;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream** streams, uint32 streamCount) Append2;
	}


	public HRESULT Initialize(IStream* stream1, IStream* stream2) mut => VT.[Friend]Initialize(&this, stream1, stream2);

	public HRESULT Initialize2(IStream** streams, uint32 streamCount) mut => VT.[Friend]Initialize2(&this, streams, streamCount);

	public HRESULT Append(IStream* stream) mut => VT.[Friend]Append(&this, stream);

	public HRESULT Append2(IStream** streams, uint32 streamCount) mut => VT.[Friend]Append2(&this, streams, streamCount);
}

[CRepr]struct IStreamInterleave : IStream
{
	public new const Guid IID = .(0x27354147, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IStream.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream** streams, uint32* interleaveSizes, uint32 streamCount) Initialize;
	}


	public HRESULT Initialize(IStream** streams, uint32* interleaveSizes, uint32 streamCount) mut => VT.[Friend]Initialize(&this, streams, interleaveSizes, streamCount);
}

[CRepr]struct IRawCDImageCreator : IDispatch
{
	public new const Guid IID = .(0x25983550, 0x9d65, 0x49ce, 0xb3, 0x35, 0x40, 0x63, 0x0d, 0x90, 0x12, 0x27);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream** resultStream) CreateResultImage;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_CD_SECTOR_TYPE dataType, IStream* data, int32* trackIndex) AddTrack;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* data) AddSpecialPregap;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* subcode) AddSubcodeRWGenerator;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE value) put_ResultingImageType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE* value) get_ResultingImageType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_StartOfLeadout;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 value) put_StartOfLeadoutLimit;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_StartOfLeadoutLimit;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_DisableGaplessAudio;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_DisableGaplessAudio;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR value) put_MediaCatalogNumber;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_MediaCatalogNumber;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 value) put_StartingTrackNumber;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_StartingTrackNumber;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 trackIndex, IRawCDImageTrackInfo** value) get_TrackInfo;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_NumberOfExistingTracks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_LastUsedUserSectorInImage;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_ExpectedTableOfContents;
	}


	public HRESULT CreateResultImage(IStream** resultStream) mut => VT.[Friend]CreateResultImage(&this, resultStream);

	public HRESULT AddTrack(IMAPI_CD_SECTOR_TYPE dataType, IStream* data, int32* trackIndex) mut => VT.[Friend]AddTrack(&this, dataType, data, trackIndex);

	public HRESULT AddSpecialPregap(IStream* data) mut => VT.[Friend]AddSpecialPregap(&this, data);

	public HRESULT AddSubcodeRWGenerator(IStream* subcode) mut => VT.[Friend]AddSubcodeRWGenerator(&this, subcode);

	public HRESULT put_ResultingImageType(IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE value) mut => VT.[Friend]put_ResultingImageType(&this, value);

	public HRESULT get_ResultingImageType(IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE* value) mut => VT.[Friend]get_ResultingImageType(&this, value);

	public HRESULT get_StartOfLeadout(int32* value) mut => VT.[Friend]get_StartOfLeadout(&this, value);

	public HRESULT put_StartOfLeadoutLimit(int32 value) mut => VT.[Friend]put_StartOfLeadoutLimit(&this, value);

	public HRESULT get_StartOfLeadoutLimit(int32* value) mut => VT.[Friend]get_StartOfLeadoutLimit(&this, value);

	public HRESULT put_DisableGaplessAudio(int16 value) mut => VT.[Friend]put_DisableGaplessAudio(&this, value);

	public HRESULT get_DisableGaplessAudio(int16* value) mut => VT.[Friend]get_DisableGaplessAudio(&this, value);

	public HRESULT put_MediaCatalogNumber(BSTR value) mut => VT.[Friend]put_MediaCatalogNumber(&this, value);

	public HRESULT get_MediaCatalogNumber(BSTR* value) mut => VT.[Friend]get_MediaCatalogNumber(&this, value);

	public HRESULT put_StartingTrackNumber(int32 value) mut => VT.[Friend]put_StartingTrackNumber(&this, value);

	public HRESULT get_StartingTrackNumber(int32* value) mut => VT.[Friend]get_StartingTrackNumber(&this, value);

	public HRESULT get_TrackInfo(int32 trackIndex, IRawCDImageTrackInfo** value) mut => VT.[Friend]get_TrackInfo(&this, trackIndex, value);

	public HRESULT get_NumberOfExistingTracks(int32* value) mut => VT.[Friend]get_NumberOfExistingTracks(&this, value);

	public HRESULT get_LastUsedUserSectorInImage(int32* value) mut => VT.[Friend]get_LastUsedUserSectorInImage(&this, value);

	public HRESULT get_ExpectedTableOfContents(SAFEARRAY** value) mut => VT.[Friend]get_ExpectedTableOfContents(&this, value);
}

[CRepr]struct IRawCDImageTrackInfo : IDispatch
{
	public new const Guid IID = .(0x25983551, 0x9d65, 0x49ce, 0xb3, 0x35, 0x40, 0x63, 0x0d, 0x90, 0x12, 0x27);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_StartingLba;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_SectorCount;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_TrackNumber;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_CD_SECTOR_TYPE* value) get_SectorType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* value) get_ISRC;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR value) put_ISRC;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_CD_TRACK_DIGITAL_COPY_SETTING* value) get_DigitalAudioCopySetting;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_CD_TRACK_DIGITAL_COPY_SETTING value) put_DigitalAudioCopySetting;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* value) get_AudioHasPreemphasis;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 value) put_AudioHasPreemphasis;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_TrackIndexes;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 lbaOffset) AddTrackIndex;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 lbaOffset) ClearTrackIndex;
	}


	public HRESULT get_StartingLba(int32* value) mut => VT.[Friend]get_StartingLba(&this, value);

	public HRESULT get_SectorCount(int32* value) mut => VT.[Friend]get_SectorCount(&this, value);

	public HRESULT get_TrackNumber(int32* value) mut => VT.[Friend]get_TrackNumber(&this, value);

	public HRESULT get_SectorType(IMAPI_CD_SECTOR_TYPE* value) mut => VT.[Friend]get_SectorType(&this, value);

	public HRESULT get_ISRC(BSTR* value) mut => VT.[Friend]get_ISRC(&this, value);

	public HRESULT put_ISRC(BSTR value) mut => VT.[Friend]put_ISRC(&this, value);

	public HRESULT get_DigitalAudioCopySetting(IMAPI_CD_TRACK_DIGITAL_COPY_SETTING* value) mut => VT.[Friend]get_DigitalAudioCopySetting(&this, value);

	public HRESULT put_DigitalAudioCopySetting(IMAPI_CD_TRACK_DIGITAL_COPY_SETTING value) mut => VT.[Friend]put_DigitalAudioCopySetting(&this, value);

	public HRESULT get_AudioHasPreemphasis(int16* value) mut => VT.[Friend]get_AudioHasPreemphasis(&this, value);

	public HRESULT put_AudioHasPreemphasis(int16 value) mut => VT.[Friend]put_AudioHasPreemphasis(&this, value);

	public HRESULT get_TrackIndexes(SAFEARRAY** value) mut => VT.[Friend]get_TrackIndexes(&this, value);

	public HRESULT AddTrackIndex(int32 lbaOffset) mut => VT.[Friend]AddTrackIndex(&this, lbaOffset);

	public HRESULT ClearTrackIndex(int32 lbaOffset) mut => VT.[Friend]ClearTrackIndex(&this, lbaOffset);
}

[CRepr]struct IBlockRange : IDispatch
{
	public new const Guid IID = .(0xb507ca25, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_StartLba;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* value) get_EndLba;
	}


	public HRESULT get_StartLba(int32* value) mut => VT.[Friend]get_StartLba(&this, value);

	public HRESULT get_EndLba(int32* value) mut => VT.[Friend]get_EndLba(&this, value);
}

[CRepr]struct IBlockRangeList : IDispatch
{
	public new const Guid IID = .(0xb507ca26, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** value) get_BlockRanges;
	}


	public HRESULT get_BlockRanges(SAFEARRAY** value) mut => VT.[Friend]get_BlockRanges(&this, value);
}

[CRepr]struct IBootOptions : IDispatch
{
	public new const Guid IID = .(0x2c941fd4, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream** pVal) get_BootImage;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_Manufacturer;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR newVal) put_Manufacturer;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, PlatformId* pVal) get_PlatformId;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, PlatformId newVal) put_PlatformId;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, EmulationType* pVal) get_Emulation;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, EmulationType newVal) put_Emulation;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32* pVal) get_ImageSize;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* newVal) AssignBootImage;
	}


	public HRESULT get_BootImage(IStream** pVal) mut => VT.[Friend]get_BootImage(&this, pVal);

	public HRESULT get_Manufacturer(BSTR* pVal) mut => VT.[Friend]get_Manufacturer(&this, pVal);

	public HRESULT put_Manufacturer(BSTR newVal) mut => VT.[Friend]put_Manufacturer(&this, newVal);

	public HRESULT get_PlatformId(PlatformId* pVal) mut => VT.[Friend]get_PlatformId(&this, pVal);

	public HRESULT put_PlatformId(PlatformId newVal) mut => VT.[Friend]put_PlatformId(&this, newVal);

	public HRESULT get_Emulation(EmulationType* pVal) mut => VT.[Friend]get_Emulation(&this, pVal);

	public HRESULT put_Emulation(EmulationType newVal) mut => VT.[Friend]put_Emulation(&this, newVal);

	public HRESULT get_ImageSize(uint32* pVal) mut => VT.[Friend]get_ImageSize(&this, pVal);

	public HRESULT AssignBootImage(IStream* newVal) mut => VT.[Friend]AssignBootImage(&this, newVal);
}

[CRepr]struct IProgressItem : IDispatch
{
	public new const Guid IID = .(0x2c941fd5, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* desc) get_Description;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32* block) get_FirstBlock;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32* block) get_LastBlock;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32* blocks) get_BlockCount;
	}


	public HRESULT get_Description(BSTR* desc) mut => VT.[Friend]get_Description(&this, desc);

	public HRESULT get_FirstBlock(uint32* block) mut => VT.[Friend]get_FirstBlock(&this, block);

	public HRESULT get_LastBlock(uint32* block) mut => VT.[Friend]get_LastBlock(&this, block);

	public HRESULT get_BlockCount(uint32* blocks) mut => VT.[Friend]get_BlockCount(&this, blocks);
}

[CRepr]struct IEnumProgressItems : IUnknown
{
	public new const Guid IID = .(0x2c941fd6, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 celt, IProgressItem** rgelt, uint32* pceltFetched) Next;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 celt) Skip;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) Reset;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumProgressItems** ppEnum) Clone;
	}


	public HRESULT Next(uint32 celt, IProgressItem** rgelt, uint32* pceltFetched) mut => VT.[Friend]Next(&this, celt, rgelt, pceltFetched);

	public HRESULT Skip(uint32 celt) mut => VT.[Friend]Skip(&this, celt);

	public HRESULT Reset() mut => VT.[Friend]Reset(&this);

	public HRESULT Clone(IEnumProgressItems** ppEnum) mut => VT.[Friend]Clone(&this, ppEnum);
}

[CRepr]struct IProgressItems : IDispatch
{
	public new const Guid IID = .(0x2c941fd7, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumVARIANT** NewEnum) get__NewEnum;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 Index, IProgressItem** item) get_Item;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* Count) get_Count;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 block, IProgressItem** item) ProgressItemFromBlock;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR description, IProgressItem** item) ProgressItemFromDescription;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumProgressItems** NewEnum) get_EnumProgressItems;
	}


	public HRESULT get__NewEnum(IEnumVARIANT** NewEnum) mut => VT.[Friend]get__NewEnum(&this, NewEnum);

	public HRESULT get_Item(int32 Index, IProgressItem** item) mut => VT.[Friend]get_Item(&this, Index, item);

	public HRESULT get_Count(int32* Count) mut => VT.[Friend]get_Count(&this, Count);

	public HRESULT ProgressItemFromBlock(uint32 block, IProgressItem** item) mut => VT.[Friend]ProgressItemFromBlock(&this, block, item);

	public HRESULT ProgressItemFromDescription(BSTR description, IProgressItem** item) mut => VT.[Friend]ProgressItemFromDescription(&this, description, item);

	public HRESULT get_EnumProgressItems(IEnumProgressItems** NewEnum) mut => VT.[Friend]get_EnumProgressItems(&this, NewEnum);
}

[CRepr]struct IFileSystemImageResult : IDispatch
{
	public new const Guid IID = .(0x2c941fd8, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream** pVal) get_ImageStream;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IProgressItems** pVal) get_ProgressItems;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_TotalBlocks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_BlockSize;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_DiscId;
	}


	public HRESULT get_ImageStream(IStream** pVal) mut => VT.[Friend]get_ImageStream(&this, pVal);

	public HRESULT get_ProgressItems(IProgressItems** pVal) mut => VT.[Friend]get_ProgressItems(&this, pVal);

	public HRESULT get_TotalBlocks(int32* pVal) mut => VT.[Friend]get_TotalBlocks(&this, pVal);

	public HRESULT get_BlockSize(int32* pVal) mut => VT.[Friend]get_BlockSize(&this, pVal);

	public HRESULT get_DiscId(BSTR* pVal) mut => VT.[Friend]get_DiscId(&this, pVal);
}

[CRepr]struct IFileSystemImageResult2 : IFileSystemImageResult
{
	public new const Guid IID = .(0xb507ca29, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IFileSystemImageResult.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IBlockRangeList** pVal) get_ModifiedBlocks;
	}


	public HRESULT get_ModifiedBlocks(IBlockRangeList** pVal) mut => VT.[Friend]get_ModifiedBlocks(&this, pVal);
}

[CRepr]struct IFsiItem : IDispatch
{
	public new const Guid IID = .(0x2c941fd9, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_Name;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_FullPath;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, double* pVal) get_CreationTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, double newVal) put_CreationTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, double* pVal) get_LastAccessedTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, double newVal) put_LastAccessedTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, double* pVal) get_LastModifiedTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, double newVal) put_LastModifiedTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* pVal) get_IsHidden;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 newVal) put_IsHidden;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, FsiFileSystems fileSystem, BSTR* pVal) FileSystemName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, FsiFileSystems fileSystem, BSTR* pVal) FileSystemPath;
	}


	public HRESULT get_Name(BSTR* pVal) mut => VT.[Friend]get_Name(&this, pVal);

	public HRESULT get_FullPath(BSTR* pVal) mut => VT.[Friend]get_FullPath(&this, pVal);

	public HRESULT get_CreationTime(double* pVal) mut => VT.[Friend]get_CreationTime(&this, pVal);

	public HRESULT put_CreationTime(double newVal) mut => VT.[Friend]put_CreationTime(&this, newVal);

	public HRESULT get_LastAccessedTime(double* pVal) mut => VT.[Friend]get_LastAccessedTime(&this, pVal);

	public HRESULT put_LastAccessedTime(double newVal) mut => VT.[Friend]put_LastAccessedTime(&this, newVal);

	public HRESULT get_LastModifiedTime(double* pVal) mut => VT.[Friend]get_LastModifiedTime(&this, pVal);

	public HRESULT put_LastModifiedTime(double newVal) mut => VT.[Friend]put_LastModifiedTime(&this, newVal);

	public HRESULT get_IsHidden(int16* pVal) mut => VT.[Friend]get_IsHidden(&this, pVal);

	public HRESULT put_IsHidden(int16 newVal) mut => VT.[Friend]put_IsHidden(&this, newVal);

	public HRESULT FileSystemName(FsiFileSystems fileSystem, BSTR* pVal) mut => VT.[Friend]FileSystemName(&this, fileSystem, pVal);

	public HRESULT FileSystemPath(FsiFileSystems fileSystem, BSTR* pVal) mut => VT.[Friend]FileSystemPath(&this, fileSystem, pVal);
}

[CRepr]struct IEnumFsiItems : IUnknown
{
	public new const Guid IID = .(0x2c941fda, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 celt, IFsiItem** rgelt, uint32* pceltFetched) Next;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 celt) Skip;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) Reset;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumFsiItems** ppEnum) Clone;
	}


	public HRESULT Next(uint32 celt, IFsiItem** rgelt, uint32* pceltFetched) mut => VT.[Friend]Next(&this, celt, rgelt, pceltFetched);

	public HRESULT Skip(uint32 celt) mut => VT.[Friend]Skip(&this, celt);

	public HRESULT Reset() mut => VT.[Friend]Reset(&this);

	public HRESULT Clone(IEnumFsiItems** ppEnum) mut => VT.[Friend]Clone(&this, ppEnum);
}

[CRepr]struct IFsiFileItem : IFsiItem
{
	public new const Guid IID = .(0x2c941fdb, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IFsiItem.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int64* pVal) get_DataSize;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_DataSize32BitLow;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_DataSize32BitHigh;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream** pVal) get_Data;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* newVal) put_Data;
	}


	public HRESULT get_DataSize(int64* pVal) mut => VT.[Friend]get_DataSize(&this, pVal);

	public HRESULT get_DataSize32BitLow(int32* pVal) mut => VT.[Friend]get_DataSize32BitLow(&this, pVal);

	public HRESULT get_DataSize32BitHigh(int32* pVal) mut => VT.[Friend]get_DataSize32BitHigh(&this, pVal);

	public HRESULT get_Data(IStream** pVal) mut => VT.[Friend]get_Data(&this, pVal);

	public HRESULT put_Data(IStream* newVal) mut => VT.[Friend]put_Data(&this, newVal);
}

[CRepr]struct IFsiFileItem2 : IFsiFileItem
{
	public new const Guid IID = .(0x199d0c19, 0x11e1, 0x40eb, 0x8e, 0xc2, 0xc8, 0xc8, 0x22, 0xa0, 0x77, 0x92);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IFsiFileItem.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IFsiNamedStreams** streams) get_FsiNamedStreams;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* pVal) get_IsNamedStream;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR name, IStream* streamData) AddStream;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR name) RemoveStream;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* pVal) get_IsRealTime;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 newVal) put_IsRealTime;
	}


	public HRESULT get_FsiNamedStreams(IFsiNamedStreams** streams) mut => VT.[Friend]get_FsiNamedStreams(&this, streams);

	public HRESULT get_IsNamedStream(int16* pVal) mut => VT.[Friend]get_IsNamedStream(&this, pVal);

	public HRESULT AddStream(BSTR name, IStream* streamData) mut => VT.[Friend]AddStream(&this, name, streamData);

	public HRESULT RemoveStream(BSTR name) mut => VT.[Friend]RemoveStream(&this, name);

	public HRESULT get_IsRealTime(int16* pVal) mut => VT.[Friend]get_IsRealTime(&this, pVal);

	public HRESULT put_IsRealTime(int16 newVal) mut => VT.[Friend]put_IsRealTime(&this, newVal);
}

[CRepr]struct IFsiNamedStreams : IDispatch
{
	public new const Guid IID = .(0xed79ba56, 0x5294, 0x4250, 0x8d, 0x46, 0xf9, 0xae, 0xce, 0xe2, 0x34, 0x59);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumVARIANT** NewEnum) get__NewEnum;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 index, IFsiFileItem2** item) get_Item;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* count) get_Count;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumFsiItems** NewEnum) get_EnumNamedStreams;
	}


	public HRESULT get__NewEnum(IEnumVARIANT** NewEnum) mut => VT.[Friend]get__NewEnum(&this, NewEnum);

	public HRESULT get_Item(int32 index, IFsiFileItem2** item) mut => VT.[Friend]get_Item(&this, index, item);

	public HRESULT get_Count(int32* count) mut => VT.[Friend]get_Count(&this, count);

	public HRESULT get_EnumNamedStreams(IEnumFsiItems** NewEnum) mut => VT.[Friend]get_EnumNamedStreams(&this, NewEnum);
}

[CRepr]struct IFsiDirectoryItem : IFsiItem
{
	public new const Guid IID = .(0x2c941fdc, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IFsiItem.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumVARIANT** NewEnum) get__NewEnum;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR path, IFsiItem** item) get_Item;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* Count) get_Count;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumFsiItems** NewEnum) get_EnumFsiItems;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR path) AddDirectory;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR path, IStream* fileData) AddFile;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR sourceDirectory, int16 includeBaseDirectory) AddTree;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IFsiItem* item) Add;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR path) Remove;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR path) RemoveTree;
	}


	public HRESULT get__NewEnum(IEnumVARIANT** NewEnum) mut => VT.[Friend]get__NewEnum(&this, NewEnum);

	public HRESULT get_Item(BSTR path, IFsiItem** item) mut => VT.[Friend]get_Item(&this, path, item);

	public HRESULT get_Count(int32* Count) mut => VT.[Friend]get_Count(&this, Count);

	public HRESULT get_EnumFsiItems(IEnumFsiItems** NewEnum) mut => VT.[Friend]get_EnumFsiItems(&this, NewEnum);

	public HRESULT AddDirectory(BSTR path) mut => VT.[Friend]AddDirectory(&this, path);

	public HRESULT AddFile(BSTR path, IStream* fileData) mut => VT.[Friend]AddFile(&this, path, fileData);

	public HRESULT AddTree(BSTR sourceDirectory, int16 includeBaseDirectory) mut => VT.[Friend]AddTree(&this, sourceDirectory, includeBaseDirectory);

	public HRESULT Add(IFsiItem* item) mut => VT.[Friend]Add(&this, item);

	public HRESULT Remove(BSTR path) mut => VT.[Friend]Remove(&this, path);

	public HRESULT RemoveTree(BSTR path) mut => VT.[Friend]RemoveTree(&this, path);
}

[CRepr]struct IFsiDirectoryItem2 : IFsiDirectoryItem
{
	public new const Guid IID = .(0xf7fb4b9b, 0x6d96, 0x4d7b, 0x91, 0x15, 0x20, 0x1b, 0x14, 0x48, 0x11, 0xef);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IFsiDirectoryItem.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR sourceDirectory, int16 includeBaseDirectory) AddTreeWithNamedStreams;
	}


	public HRESULT AddTreeWithNamedStreams(BSTR sourceDirectory, int16 includeBaseDirectory) mut => VT.[Friend]AddTreeWithNamedStreams(&this, sourceDirectory, includeBaseDirectory);
}

[CRepr]struct IFileSystemImage : IDispatch
{
	public new const Guid IID = .(0x2c941fe1, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IFsiDirectoryItem** pVal) get_Root;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_SessionStartBlock;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 newVal) put_SessionStartBlock;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_FreeMediaBlocks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 newVal) put_FreeMediaBlocks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2* discRecorder) SetMaxMediaBlocksFromDevice;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_UsedBlocks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_VolumeName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR newVal) put_VolumeName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_ImportedVolumeName;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IBootOptions** pVal) get_BootImageOptions;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IBootOptions* newVal) put_BootImageOptions;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_FileCount;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_DirectoryCount;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_WorkingDirectory;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR newVal) put_WorkingDirectory;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_ChangePoint;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* pVal) get_StrictFileSystemCompliance;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 newVal) put_StrictFileSystemCompliance;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* pVal) get_UseRestrictedCharacterSet;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 newVal) put_UseRestrictedCharacterSet;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, FsiFileSystems* pVal) get_FileSystemsToCreate;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, FsiFileSystems newVal) put_FileSystemsToCreate;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, FsiFileSystems* pVal) get_FileSystemsSupported;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 newVal) put_UDFRevision;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_UDFRevision;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** pVal) get_UDFRevisionsSupported;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2* discRecorder) ChooseImageDefaults;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IMAPI_MEDIA_PHYSICAL_TYPE value) ChooseImageDefaultsForMediaType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 newVal) put_ISO9660InterchangeLevel;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pVal) get_ISO9660InterchangeLevel;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** pVal) get_ISO9660InterchangeLevelsSupported;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IFileSystemImageResult** resultStream) CreateResultImage;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR fullPath, FsiItemType* itemType) Exists;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* discIdentifier) CalculateDiscIdentifier;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder2* discRecorder, FsiFileSystems* fileSystems) IdentifyFileSystemsOnDisc;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, FsiFileSystems fileSystems, FsiFileSystems* importDefault) GetDefaultFileSystemForImport;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, FsiFileSystems* importedFileSystem) ImportFileSystem;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, FsiFileSystems fileSystemToUse) ImportSpecificFileSystem;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 changePoint) RollbackToChangePoint;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) LockInChangePoint;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR name, IFsiDirectoryItem** newItem) CreateDirectoryItem;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR name, IFsiFileItem** newItem) CreateFileItem;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_VolumeNameUDF;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_VolumeNameJoliet;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_VolumeNameISO9660;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* pVal) get_StageFiles;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 newVal) put_StageFiles;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** pVal) get_MultisessionInterfaces;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY* newVal) put_MultisessionInterfaces;
	}


	public HRESULT get_Root(IFsiDirectoryItem** pVal) mut => VT.[Friend]get_Root(&this, pVal);

	public HRESULT get_SessionStartBlock(int32* pVal) mut => VT.[Friend]get_SessionStartBlock(&this, pVal);

	public HRESULT put_SessionStartBlock(int32 newVal) mut => VT.[Friend]put_SessionStartBlock(&this, newVal);

	public HRESULT get_FreeMediaBlocks(int32* pVal) mut => VT.[Friend]get_FreeMediaBlocks(&this, pVal);

	public HRESULT put_FreeMediaBlocks(int32 newVal) mut => VT.[Friend]put_FreeMediaBlocks(&this, newVal);

	public HRESULT SetMaxMediaBlocksFromDevice(IDiscRecorder2* discRecorder) mut => VT.[Friend]SetMaxMediaBlocksFromDevice(&this, discRecorder);

	public HRESULT get_UsedBlocks(int32* pVal) mut => VT.[Friend]get_UsedBlocks(&this, pVal);

	public HRESULT get_VolumeName(BSTR* pVal) mut => VT.[Friend]get_VolumeName(&this, pVal);

	public HRESULT put_VolumeName(BSTR newVal) mut => VT.[Friend]put_VolumeName(&this, newVal);

	public HRESULT get_ImportedVolumeName(BSTR* pVal) mut => VT.[Friend]get_ImportedVolumeName(&this, pVal);

	public HRESULT get_BootImageOptions(IBootOptions** pVal) mut => VT.[Friend]get_BootImageOptions(&this, pVal);

	public HRESULT put_BootImageOptions(IBootOptions* newVal) mut => VT.[Friend]put_BootImageOptions(&this, newVal);

	public HRESULT get_FileCount(int32* pVal) mut => VT.[Friend]get_FileCount(&this, pVal);

	public HRESULT get_DirectoryCount(int32* pVal) mut => VT.[Friend]get_DirectoryCount(&this, pVal);

	public HRESULT get_WorkingDirectory(BSTR* pVal) mut => VT.[Friend]get_WorkingDirectory(&this, pVal);

	public HRESULT put_WorkingDirectory(BSTR newVal) mut => VT.[Friend]put_WorkingDirectory(&this, newVal);

	public HRESULT get_ChangePoint(int32* pVal) mut => VT.[Friend]get_ChangePoint(&this, pVal);

	public HRESULT get_StrictFileSystemCompliance(int16* pVal) mut => VT.[Friend]get_StrictFileSystemCompliance(&this, pVal);

	public HRESULT put_StrictFileSystemCompliance(int16 newVal) mut => VT.[Friend]put_StrictFileSystemCompliance(&this, newVal);

	public HRESULT get_UseRestrictedCharacterSet(int16* pVal) mut => VT.[Friend]get_UseRestrictedCharacterSet(&this, pVal);

	public HRESULT put_UseRestrictedCharacterSet(int16 newVal) mut => VT.[Friend]put_UseRestrictedCharacterSet(&this, newVal);

	public HRESULT get_FileSystemsToCreate(FsiFileSystems* pVal) mut => VT.[Friend]get_FileSystemsToCreate(&this, pVal);

	public HRESULT put_FileSystemsToCreate(FsiFileSystems newVal) mut => VT.[Friend]put_FileSystemsToCreate(&this, newVal);

	public HRESULT get_FileSystemsSupported(FsiFileSystems* pVal) mut => VT.[Friend]get_FileSystemsSupported(&this, pVal);

	public HRESULT put_UDFRevision(int32 newVal) mut => VT.[Friend]put_UDFRevision(&this, newVal);

	public HRESULT get_UDFRevision(int32* pVal) mut => VT.[Friend]get_UDFRevision(&this, pVal);

	public HRESULT get_UDFRevisionsSupported(SAFEARRAY** pVal) mut => VT.[Friend]get_UDFRevisionsSupported(&this, pVal);

	public HRESULT ChooseImageDefaults(IDiscRecorder2* discRecorder) mut => VT.[Friend]ChooseImageDefaults(&this, discRecorder);

	public HRESULT ChooseImageDefaultsForMediaType(IMAPI_MEDIA_PHYSICAL_TYPE value) mut => VT.[Friend]ChooseImageDefaultsForMediaType(&this, value);

	public HRESULT put_ISO9660InterchangeLevel(int32 newVal) mut => VT.[Friend]put_ISO9660InterchangeLevel(&this, newVal);

	public HRESULT get_ISO9660InterchangeLevel(int32* pVal) mut => VT.[Friend]get_ISO9660InterchangeLevel(&this, pVal);

	public HRESULT get_ISO9660InterchangeLevelsSupported(SAFEARRAY** pVal) mut => VT.[Friend]get_ISO9660InterchangeLevelsSupported(&this, pVal);

	public HRESULT CreateResultImage(IFileSystemImageResult** resultStream) mut => VT.[Friend]CreateResultImage(&this, resultStream);

	public HRESULT Exists(BSTR fullPath, FsiItemType* itemType) mut => VT.[Friend]Exists(&this, fullPath, itemType);

	public HRESULT CalculateDiscIdentifier(BSTR* discIdentifier) mut => VT.[Friend]CalculateDiscIdentifier(&this, discIdentifier);

	public HRESULT IdentifyFileSystemsOnDisc(IDiscRecorder2* discRecorder, FsiFileSystems* fileSystems) mut => VT.[Friend]IdentifyFileSystemsOnDisc(&this, discRecorder, fileSystems);

	public HRESULT GetDefaultFileSystemForImport(FsiFileSystems fileSystems, FsiFileSystems* importDefault) mut => VT.[Friend]GetDefaultFileSystemForImport(&this, fileSystems, importDefault);

	public HRESULT ImportFileSystem(FsiFileSystems* importedFileSystem) mut => VT.[Friend]ImportFileSystem(&this, importedFileSystem);

	public HRESULT ImportSpecificFileSystem(FsiFileSystems fileSystemToUse) mut => VT.[Friend]ImportSpecificFileSystem(&this, fileSystemToUse);

	public HRESULT RollbackToChangePoint(int32 changePoint) mut => VT.[Friend]RollbackToChangePoint(&this, changePoint);

	public HRESULT LockInChangePoint() mut => VT.[Friend]LockInChangePoint(&this);

	public HRESULT CreateDirectoryItem(BSTR name, IFsiDirectoryItem** newItem) mut => VT.[Friend]CreateDirectoryItem(&this, name, newItem);

	public HRESULT CreateFileItem(BSTR name, IFsiFileItem** newItem) mut => VT.[Friend]CreateFileItem(&this, name, newItem);

	public HRESULT get_VolumeNameUDF(BSTR* pVal) mut => VT.[Friend]get_VolumeNameUDF(&this, pVal);

	public HRESULT get_VolumeNameJoliet(BSTR* pVal) mut => VT.[Friend]get_VolumeNameJoliet(&this, pVal);

	public HRESULT get_VolumeNameISO9660(BSTR* pVal) mut => VT.[Friend]get_VolumeNameISO9660(&this, pVal);

	public HRESULT get_StageFiles(int16* pVal) mut => VT.[Friend]get_StageFiles(&this, pVal);

	public HRESULT put_StageFiles(int16 newVal) mut => VT.[Friend]put_StageFiles(&this, newVal);

	public HRESULT get_MultisessionInterfaces(SAFEARRAY** pVal) mut => VT.[Friend]get_MultisessionInterfaces(&this, pVal);

	public HRESULT put_MultisessionInterfaces(SAFEARRAY* newVal) mut => VT.[Friend]put_MultisessionInterfaces(&this, newVal);
}

[CRepr]struct IFileSystemImage2 : IFileSystemImage
{
	public new const Guid IID = .(0xd7644b2c, 0x1537, 0x4767, 0xb6, 0x2f, 0xf1, 0x38, 0x7b, 0x02, 0xdd, 0xfd);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IFileSystemImage.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY** pVal) get_BootImageOptionsArray;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, SAFEARRAY* newVal) put_BootImageOptionsArray;
	}


	public HRESULT get_BootImageOptionsArray(SAFEARRAY** pVal) mut => VT.[Friend]get_BootImageOptionsArray(&this, pVal);

	public HRESULT put_BootImageOptionsArray(SAFEARRAY* newVal) mut => VT.[Friend]put_BootImageOptionsArray(&this, newVal);
}

[CRepr]struct IFileSystemImage3 : IFileSystemImage2
{
	public new const Guid IID = .(0x7cff842c, 0x7e97, 0x4807, 0x83, 0x04, 0x91, 0x0d, 0xd8, 0xf7, 0xc0, 0x51);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IFileSystemImage2.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16* pVal) get_CreateRedundantUdfMetadataFiles;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int16 newVal) put_CreateRedundantUdfMetadataFiles;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, FsiFileSystems fileSystemToProbe, int16* isAppendable) ProbeSpecificFileSystem;
	}


	public HRESULT get_CreateRedundantUdfMetadataFiles(int16* pVal) mut => VT.[Friend]get_CreateRedundantUdfMetadataFiles(&this, pVal);

	public HRESULT put_CreateRedundantUdfMetadataFiles(int16 newVal) mut => VT.[Friend]put_CreateRedundantUdfMetadataFiles(&this, newVal);

	public HRESULT ProbeSpecificFileSystem(FsiFileSystems fileSystemToProbe, int16* isAppendable) mut => VT.[Friend]ProbeSpecificFileSystem(&this, fileSystemToProbe, isAppendable);
}

[CRepr]struct DFileSystemImageEvents : IDispatch
{
	public new const Guid IID = .(0x2c941fdf, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDispatch* object, BSTR currentFile, int32 copiedSectors, int32 totalSectors) Update;
	}


	public HRESULT Update(IDispatch* object, BSTR currentFile, int32 copiedSectors, int32 totalSectors) mut => VT.[Friend]Update(&this, object, currentFile, copiedSectors, totalSectors);
}

[CRepr]struct DFileSystemImageImportEvents : IDispatch
{
	public new const Guid IID = .(0xd25c30f9, 0x4087, 0x4366, 0x9e, 0x24, 0xe5, 0x5b, 0xe2, 0x86, 0x42, 0x4b);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDispatch* object, FsiFileSystems fileSystem, BSTR currentItem, int32 importedDirectoryItems, int32 totalDirectoryItems, int32 importedFileItems, int32 totalFileItems) UpdateImport;
	}


	public HRESULT UpdateImport(IDispatch* object, FsiFileSystems fileSystem, BSTR currentItem, int32 importedDirectoryItems, int32 totalDirectoryItems, int32 importedFileItems, int32 totalFileItems) mut => VT.[Friend]UpdateImport(&this, object, fileSystem, currentItem, importedDirectoryItems, totalDirectoryItems, importedFileItems, totalFileItems);
}

[CRepr]struct IIsoImageManager : IDispatch
{
	public new const Guid IID = .(0x6ca38be5, 0xfbbb, 0x4800, 0x95, 0xa1, 0xa4, 0x38, 0x86, 0x5e, 0xb0, 0xd4);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IDispatch.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pVal) get_Path;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream** data) get_Stream;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR Val) SetPath;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStream* data) SetStream;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) Validate;
	}


	public HRESULT get_Path(BSTR* pVal) mut => VT.[Friend]get_Path(&this, pVal);

	public HRESULT get_Stream(IStream** data) mut => VT.[Friend]get_Stream(&this, data);

	public HRESULT SetPath(BSTR Val) mut => VT.[Friend]SetPath(&this, Val);

	public HRESULT SetStream(IStream* data) mut => VT.[Friend]SetStream(&this, data);

	public HRESULT Validate() mut => VT.[Friend]Validate(&this);
}

[CRepr]struct IDiscRecorder : IUnknown
{
	public new const Guid IID = .(0x85ac9776, 0xca88, 0x4cf2, 0x89, 0x4e, 0x09, 0x59, 0x8c, 0x07, 0x8a, 0x41);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8* pbyUniqueID, uint32 nulIDSize, uint32 nulDriveNumber) Init;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8* pbyUniqueID, uint32 ulBufferSize, uint32* pulReturnSizeRequired) GetRecorderGUID;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, RECORDER_TYPES* fTypeCode) GetRecorderType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pbstrVendorID, BSTR* pbstrProductID, BSTR* pbstrRevision) GetDisplayNames;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pbstrBasePnPID) GetBasePnPID;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, BSTR* pbstrPath) GetPath;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IPropertyStorage** ppPropStg) GetRecorderProperties;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IPropertyStorage* pPropStg) SetRecorderProperties;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, DISC_RECORDER_STATE_FLAGS* pulDevStateFlags) GetRecorderState;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) OpenExclusive;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, MEDIA_TYPES* fMediaType, MEDIA_FLAGS* fMediaFlags) QueryMediaType;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8* pbSessions, uint8* pbLastTrack, uint32* ulStartAddress, uint32* ulNextWritable, uint32* ulFreeBlocks) QueryMediaInfo;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) Eject;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8 bFullErase) Erase;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) Close;
	}


	public HRESULT Init(uint8* pbyUniqueID, uint32 nulIDSize, uint32 nulDriveNumber) mut => VT.[Friend]Init(&this, pbyUniqueID, nulIDSize, nulDriveNumber);

	public HRESULT GetRecorderGUID(uint8* pbyUniqueID, uint32 ulBufferSize, uint32* pulReturnSizeRequired) mut => VT.[Friend]GetRecorderGUID(&this, pbyUniqueID, ulBufferSize, pulReturnSizeRequired);

	public HRESULT GetRecorderType(RECORDER_TYPES* fTypeCode) mut => VT.[Friend]GetRecorderType(&this, fTypeCode);

	public HRESULT GetDisplayNames(BSTR* pbstrVendorID, BSTR* pbstrProductID, BSTR* pbstrRevision) mut => VT.[Friend]GetDisplayNames(&this, pbstrVendorID, pbstrProductID, pbstrRevision);

	public HRESULT GetBasePnPID(BSTR* pbstrBasePnPID) mut => VT.[Friend]GetBasePnPID(&this, pbstrBasePnPID);

	public HRESULT GetPath(BSTR* pbstrPath) mut => VT.[Friend]GetPath(&this, pbstrPath);

	public HRESULT GetRecorderProperties(IPropertyStorage** ppPropStg) mut => VT.[Friend]GetRecorderProperties(&this, ppPropStg);

	public HRESULT SetRecorderProperties(IPropertyStorage* pPropStg) mut => VT.[Friend]SetRecorderProperties(&this, pPropStg);

	public HRESULT GetRecorderState(DISC_RECORDER_STATE_FLAGS* pulDevStateFlags) mut => VT.[Friend]GetRecorderState(&this, pulDevStateFlags);

	public HRESULT OpenExclusive() mut => VT.[Friend]OpenExclusive(&this);

	public HRESULT QueryMediaType(MEDIA_TYPES* fMediaType, MEDIA_FLAGS* fMediaFlags) mut => VT.[Friend]QueryMediaType(&this, fMediaType, fMediaFlags);

	public HRESULT QueryMediaInfo(uint8* pbSessions, uint8* pbLastTrack, uint32* ulStartAddress, uint32* ulNextWritable, uint32* ulFreeBlocks) mut => VT.[Friend]QueryMediaInfo(&this, pbSessions, pbLastTrack, ulStartAddress, ulNextWritable, ulFreeBlocks);

	public HRESULT Eject() mut => VT.[Friend]Eject(&this);

	public HRESULT Erase(uint8 bFullErase) mut => VT.[Friend]Erase(&this, bFullErase);

	public HRESULT Close() mut => VT.[Friend]Close(&this);
}

[CRepr]struct IEnumDiscRecorders : IUnknown
{
	public new const Guid IID = .(0x9b1921e1, 0x54ac, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 cRecorders, IDiscRecorder** ppRecorder, uint32* pcFetched) Next;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 cRecorders) Skip;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) Reset;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumDiscRecorders** ppEnum) Clone;
	}


	public HRESULT Next(uint32 cRecorders, IDiscRecorder** ppRecorder, uint32* pcFetched) mut => VT.[Friend]Next(&this, cRecorders, ppRecorder, pcFetched);

	public HRESULT Skip(uint32 cRecorders) mut => VT.[Friend]Skip(&this, cRecorders);

	public HRESULT Reset() mut => VT.[Friend]Reset(&this);

	public HRESULT Clone(IEnumDiscRecorders** ppEnum) mut => VT.[Friend]Clone(&this, ppEnum);
}

[CRepr]struct IEnumDiscMasterFormats : IUnknown
{
	public new const Guid IID = .(0xddf445e1, 0x54ba, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 cFormats, Guid* lpiidFormatID, uint32* pcFetched) Next;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint32 cFormats) Skip;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) Reset;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumDiscMasterFormats** ppEnum) Clone;
	}


	public HRESULT Next(uint32 cFormats, Guid* lpiidFormatID, uint32* pcFetched) mut => VT.[Friend]Next(&this, cFormats, lpiidFormatID, pcFetched);

	public HRESULT Skip(uint32 cFormats) mut => VT.[Friend]Skip(&this, cFormats);

	public HRESULT Reset() mut => VT.[Friend]Reset(&this);

	public HRESULT Clone(IEnumDiscMasterFormats** ppEnum) mut => VT.[Friend]Clone(&this, ppEnum);
}

[CRepr]struct IRedbookDiscMaster : IUnknown
{
	public new const Guid IID = .(0xe3bc42cd, 0x4e5c, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pnTracks) GetTotalAudioTracks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pnBlocks) GetTotalAudioBlocks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pnBlocks) GetUsedAudioBlocks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pnBlocks) GetAvailableAudioTrackBlocks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pnBlockBytes) GetAudioBlockSize;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 nBlocks) CreateAudioTrack;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8* pby, int32 cb) AddAudioTrackBlocks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) CloseAudioTrack;
	}


	public HRESULT GetTotalAudioTracks(int32* pnTracks) mut => VT.[Friend]GetTotalAudioTracks(&this, pnTracks);

	public HRESULT GetTotalAudioBlocks(int32* pnBlocks) mut => VT.[Friend]GetTotalAudioBlocks(&this, pnBlocks);

	public HRESULT GetUsedAudioBlocks(int32* pnBlocks) mut => VT.[Friend]GetUsedAudioBlocks(&this, pnBlocks);

	public HRESULT GetAvailableAudioTrackBlocks(int32* pnBlocks) mut => VT.[Friend]GetAvailableAudioTrackBlocks(&this, pnBlocks);

	public HRESULT GetAudioBlockSize(int32* pnBlockBytes) mut => VT.[Friend]GetAudioBlockSize(&this, pnBlockBytes);

	public HRESULT CreateAudioTrack(int32 nBlocks) mut => VT.[Friend]CreateAudioTrack(&this, nBlocks);

	public HRESULT AddAudioTrackBlocks(uint8* pby, int32 cb) mut => VT.[Friend]AddAudioTrackBlocks(&this, pby, cb);

	public HRESULT CloseAudioTrack() mut => VT.[Friend]CloseAudioTrack(&this);
}

[CRepr]struct IJolietDiscMaster : IUnknown
{
	public new const Guid IID = .(0xe3bc42ce, 0x4e5c, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pnBlocks) GetTotalDataBlocks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pnBlocks) GetUsedDataBlocks;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32* pnBlockBytes) GetDataBlockSize;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IStorage* pStorage, int32 lFileOverwrite) AddData;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IPropertyStorage** ppPropStg) GetJolietProperties;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IPropertyStorage* pPropStg) SetJolietProperties;
	}


	public HRESULT GetTotalDataBlocks(int32* pnBlocks) mut => VT.[Friend]GetTotalDataBlocks(&this, pnBlocks);

	public HRESULT GetUsedDataBlocks(int32* pnBlocks) mut => VT.[Friend]GetUsedDataBlocks(&this, pnBlocks);

	public HRESULT GetDataBlockSize(int32* pnBlockBytes) mut => VT.[Friend]GetDataBlockSize(&this, pnBlockBytes);

	public HRESULT AddData(IStorage* pStorage, int32 lFileOverwrite) mut => VT.[Friend]AddData(&this, pStorage, lFileOverwrite);

	public HRESULT GetJolietProperties(IPropertyStorage** ppPropStg) mut => VT.[Friend]GetJolietProperties(&this, ppPropStg);

	public HRESULT SetJolietProperties(IPropertyStorage* pPropStg) mut => VT.[Friend]SetJolietProperties(&this, pPropStg);
}

[CRepr]struct IDiscMasterProgressEvents : IUnknown
{
	public new const Guid IID = .(0xec9e51c1, 0x4e5d, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8* pbCancel) QueryCancel;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) NotifyPnPActivity;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 nCompletedSteps, int32 nTotalSteps) NotifyAddProgress;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 nCompleted, int32 nTotal) NotifyBlockProgress;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 nCurrentTrack, int32 nTotalTracks) NotifyTrackProgress;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 nEstimatedSeconds) NotifyPreparingBurn;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, int32 nEstimatedSeconds) NotifyClosingDisc;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, HRESULT status) NotifyBurnComplete;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, HRESULT status) NotifyEraseComplete;
	}


	public HRESULT QueryCancel(uint8* pbCancel) mut => VT.[Friend]QueryCancel(&this, pbCancel);

	public HRESULT NotifyPnPActivity() mut => VT.[Friend]NotifyPnPActivity(&this);

	public HRESULT NotifyAddProgress(int32 nCompletedSteps, int32 nTotalSteps) mut => VT.[Friend]NotifyAddProgress(&this, nCompletedSteps, nTotalSteps);

	public HRESULT NotifyBlockProgress(int32 nCompleted, int32 nTotal) mut => VT.[Friend]NotifyBlockProgress(&this, nCompleted, nTotal);

	public HRESULT NotifyTrackProgress(int32 nCurrentTrack, int32 nTotalTracks) mut => VT.[Friend]NotifyTrackProgress(&this, nCurrentTrack, nTotalTracks);

	public HRESULT NotifyPreparingBurn(int32 nEstimatedSeconds) mut => VT.[Friend]NotifyPreparingBurn(&this, nEstimatedSeconds);

	public HRESULT NotifyClosingDisc(int32 nEstimatedSeconds) mut => VT.[Friend]NotifyClosingDisc(&this, nEstimatedSeconds);

	public HRESULT NotifyBurnComplete(HRESULT status) mut => VT.[Friend]NotifyBurnComplete(&this, status);

	public HRESULT NotifyEraseComplete(HRESULT status) mut => VT.[Friend]NotifyEraseComplete(&this, status);
}

[CRepr]struct IDiscMaster : IUnknown
{
	public new const Guid IID = .(0x520cca62, 0x51a5, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);

	public new VTable* VT { get => (.)mVT; }

	[CRepr]public struct VTable : IUnknown.VTable
	{
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) Open;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumDiscMasterFormats** ppEnum) EnumDiscMasterFormats;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, Guid* lpiid) GetActiveDiscMasterFormat;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, in Guid riid, void** ppUnk) SetActiveDiscMasterFormat;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IEnumDiscRecorders** ppEnum) EnumDiscRecorders;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder** ppRecorder) GetActiveDiscRecorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscRecorder* pRecorder) SetActiveDiscRecorder;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) ClearFormatContent;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, IDiscMasterProgressEvents* pEvents, uint* pvCookie) ProgressAdvise;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint vCookie) ProgressUnadvise;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self, uint8 bSimulate, uint8 bEjectAfterBurn) RecordDisc;
		protected new function [CallingConvention(.Stdcall)] HRESULT(SelfOuter* self) Close;
	}


	public HRESULT Open() mut => VT.[Friend]Open(&this);

	public HRESULT EnumDiscMasterFormats(IEnumDiscMasterFormats** ppEnum) mut => VT.[Friend]EnumDiscMasterFormats(&this, ppEnum);

	public HRESULT GetActiveDiscMasterFormat(Guid* lpiid) mut => VT.[Friend]GetActiveDiscMasterFormat(&this, lpiid);

	public HRESULT SetActiveDiscMasterFormat(in Guid riid, void** ppUnk) mut => VT.[Friend]SetActiveDiscMasterFormat(&this, riid, ppUnk);

	public HRESULT EnumDiscRecorders(IEnumDiscRecorders** ppEnum) mut => VT.[Friend]EnumDiscRecorders(&this, ppEnum);

	public HRESULT GetActiveDiscRecorder(IDiscRecorder** ppRecorder) mut => VT.[Friend]GetActiveDiscRecorder(&this, ppRecorder);

	public HRESULT SetActiveDiscRecorder(IDiscRecorder* pRecorder) mut => VT.[Friend]SetActiveDiscRecorder(&this, pRecorder);

	public HRESULT ClearFormatContent() mut => VT.[Friend]ClearFormatContent(&this);

	public HRESULT ProgressAdvise(IDiscMasterProgressEvents* pEvents, uint* pvCookie) mut => VT.[Friend]ProgressAdvise(&this, pEvents, pvCookie);

	public HRESULT ProgressUnadvise(uint vCookie) mut => VT.[Friend]ProgressUnadvise(&this, vCookie);

	public HRESULT RecordDisc(uint8 bSimulate, uint8 bEjectAfterBurn) mut => VT.[Friend]RecordDisc(&this, bSimulate, bEjectAfterBurn);

	public HRESULT Close() mut => VT.[Friend]Close(&this);
}

#endregion

#region Functions
public static
{
	[Import("MAPI32.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern int32 OpenIMsgSession(IMalloc* lpMalloc, uint32 ulFlags, _MSGSESS** lppMsgSess);

	[Import("MAPI32.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern void CloseIMsgSession(_MSGSESS* lpMsgSess);

	[Import("MAPI32.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern int32 OpenIMsgOnIStg(_MSGSESS* lpMsgSess, LPALLOCATEBUFFER lpAllocateBuffer, LPALLOCATEMORE lpAllocateMore, LPFREEBUFFER lpFreeBuffer, IMalloc* lpMalloc, void* lpMapiSup, IStorage* lpStg, MSGCALLRELEASE* lpfMsgCallRelease, uint32 ulCallerData, uint32 ulFlags, IMessage** lppMsg);

	[Import("MAPI32.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern HRESULT GetAttribIMsgOnIStg(void* lpObject, SPropTagArray* lpPropTagArray, SPropAttrArray** lppPropAttrArray);

	[Import("MAPI32.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern HRESULT SetAttribIMsgOnIStg(void* lpObject, SPropTagArray* lpPropTags, SPropAttrArray* lpPropAttrs, SPropProblemArray** lppPropProblems);

	[Import("MAPI32.lib"), CLink, CallingConvention(.Stdcall)]
	public static extern int32 MapStorageSCode(int32 StgSCode);

}
#endregion
